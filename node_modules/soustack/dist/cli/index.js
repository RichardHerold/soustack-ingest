#!/usr/bin/env node
'use strict';

var fs = require('fs');
var path = require('path');
var glob = require('glob');
var cheerio = require('cheerio');
var Ajv2020 = require('ajv/dist/2020');
var addFormats = require('ajv-formats');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var Ajv2020__default = /*#__PURE__*/_interopDefault(Ajv2020);
var addFormats__default = /*#__PURE__*/_interopDefault(addFormats);

var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/parsers/duration.ts
var ISO_DURATION_REGEX = /^P(?:(\d+(?:\.\d+)?)D)?(?:T(?:(\d+(?:\.\d+)?)H)?(?:(\d+(?:\.\d+)?)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
var HUMAN_OVERNIGHT = 8 * 60;
function isFiniteNumber(value) {
  return typeof value === "number" && Number.isFinite(value);
}
function parseDuration(iso) {
  if (typeof iso === "number" && Number.isFinite(iso)) {
    return iso;
  }
  if (!iso || typeof iso !== "string") return null;
  const trimmed = iso.trim();
  if (!trimmed) return null;
  const match = trimmed.match(ISO_DURATION_REGEX);
  if (!match) return null;
  const [, daysRaw, hoursRaw, minutesRaw, secondsRaw] = match;
  if (!daysRaw && !hoursRaw && !minutesRaw && !secondsRaw) {
    return null;
  }
  let total = 0;
  if (daysRaw) total += parseFloat(daysRaw) * 24 * 60;
  if (hoursRaw) total += parseFloat(hoursRaw) * 60;
  if (minutesRaw) total += parseFloat(minutesRaw);
  if (secondsRaw) total += Math.ceil(parseFloat(secondsRaw) / 60);
  return Math.round(total);
}
function formatDuration(minutes) {
  if (!isFiniteNumber(minutes) || minutes <= 0) {
    return "PT0M";
  }
  const rounded = Math.round(minutes);
  const days = Math.floor(rounded / (24 * 60));
  const afterDays = rounded % (24 * 60);
  const hours = Math.floor(afterDays / 60);
  const mins = afterDays % 60;
  let result = "P";
  if (days > 0) {
    result += `${days}D`;
  }
  if (hours > 0 || mins > 0) {
    result += "T";
    if (hours > 0) {
      result += `${hours}H`;
    }
    if (mins > 0) {
      result += `${mins}M`;
    }
  }
  if (result === "P") {
    return "PT0M";
  }
  return result;
}
function parseHumanDuration(text) {
  if (!text || typeof text !== "string") return null;
  const normalized = text.toLowerCase().trim();
  if (!normalized) return null;
  if (normalized === "overnight") {
    return HUMAN_OVERNIGHT;
  }
  let total = 0;
  const hourRegex = /(\d+(?:\.\d+)?)\s*(?:hours?|hrs?|hr|h)\b/g;
  let hourMatch;
  while ((hourMatch = hourRegex.exec(normalized)) !== null) {
    total += parseFloat(hourMatch[1]) * 60;
  }
  const minuteRegex = /(\d+(?:\.\d+)?)\s*(?:minutes?|mins?|min|m)\b/g;
  let minuteMatch;
  while ((minuteMatch = minuteRegex.exec(normalized)) !== null) {
    total += parseFloat(minuteMatch[1]);
  }
  if (total <= 0) {
    return null;
  }
  return Math.round(total);
}
function smartParseDuration(input) {
  const iso = parseDuration(input);
  if (iso !== null) {
    return iso;
  }
  return parseHumanDuration(input);
}

// src/parser.ts
function scaleRecipe(recipe, options = {}) {
  const multiplier = resolveMultiplier(recipe, options);
  const scaled = deepClone(recipe);
  applyYieldScaling(scaled, options, multiplier);
  const baseAmounts = collectBaseIngredientAmounts(scaled.ingredients || []);
  const scaledAmounts = /* @__PURE__ */ new Map();
  const orderedIngredients = [];
  collectIngredients(scaled.ingredients || [], orderedIngredients);
  orderedIngredients.filter((ing) => (ing.scaling?.type || "linear") !== "bakers_percentage").forEach((ing) => {
    const key = getIngredientKey(ing);
    scaledAmounts.set(key, calculateIndependentIngredient(ing, multiplier));
  });
  orderedIngredients.filter((ing) => ing.scaling?.type === "bakers_percentage").forEach((ing) => {
    const key = getIngredientKey(ing);
    const scaling = ing.scaling;
    if (!scaling?.referenceId) {
      throw new Error(`Baker's percentage ingredient "${key}" is missing a referenceId`);
    }
    const referenceAmount = scaledAmounts.get(scaling.referenceId);
    if (referenceAmount === void 0) {
      throw new Error(`Reference ingredient "${scaling.referenceId}" not found for baker's percentage item "${key}"`);
    }
    const baseAmount = ing.quantity?.amount || 0;
    const referenceBase = baseAmounts.get(scaling.referenceId);
    const factor = scaling.factor ?? (referenceBase ? baseAmount / referenceBase : void 0);
    if (factor === void 0) {
      throw new Error(`Unable to determine factor for baker's percentage ingredient "${key}"`);
    }
    scaledAmounts.set(key, referenceAmount * factor);
  });
  orderedIngredients.forEach((ing) => {
    const key = getIngredientKey(ing);
    const amount = scaledAmounts.get(key);
    if (amount === void 0) return;
    if (!ing.quantity) {
      ing.quantity = { amount, unit: null };
    } else {
      ing.quantity.amount = amount;
    }
  });
  scaleInstructionItems(scaled.instructions || [], multiplier);
  return scaled;
}
function resolveMultiplier(recipe, options) {
  if (options.multiplier && options.multiplier > 0) {
    return options.multiplier;
  }
  if (options.targetYield?.amount) {
    const base = recipe.yield?.amount || 1;
    return options.targetYield.amount / base;
  }
  return 1;
}
function applyYieldScaling(recipe, options, multiplier) {
  const baseAmount = recipe.yield?.amount ?? 1;
  const targetAmount = options.targetYield?.amount ?? baseAmount * multiplier;
  const unit = options.targetYield?.unit ?? recipe.yield?.unit;
  if (!recipe.yield && !options.targetYield) return;
  recipe.yield = {
    amount: targetAmount,
    unit: unit ?? ""
  };
}
function getIngredientKey(ing) {
  return ing.id || ing.item;
}
function calculateIndependentIngredient(ing, multiplier) {
  const baseAmount = ing.quantity?.amount || 0;
  const type = ing.scaling?.type || "linear";
  switch (type) {
    case "fixed":
      return baseAmount;
    case "discrete": {
      const scaled = baseAmount * multiplier;
      const step = ing.scaling?.roundTo ?? 1;
      const rounded = Math.round(scaled / step) * step;
      return Math.round(rounded);
    }
    case "proportional": {
      const factor = ing.scaling?.factor ?? 1;
      return baseAmount * multiplier * factor;
    }
    default:
      return baseAmount * multiplier;
  }
}
function collectIngredients(items, bucket) {
  items.forEach((item) => {
    if (typeof item === "string") return;
    if ("subsection" in item) {
      collectIngredients(item.items, bucket);
    } else {
      bucket.push(item);
    }
  });
}
function collectBaseIngredientAmounts(items, map = /* @__PURE__ */ new Map()) {
  items.forEach((item) => {
    if (typeof item === "string") return;
    if ("subsection" in item) {
      collectBaseIngredientAmounts(item.items, map);
    } else {
      map.set(getIngredientKey(item), item.quantity?.amount ?? 0);
    }
  });
  return map;
}
function scaleInstructionItems(items, multiplier) {
  items.forEach((item) => {
    if (typeof item === "string") return;
    if ("subsection" in item) {
      scaleInstructionItems(item.items, multiplier);
      return;
    }
    const timing = item.timing;
    if (!timing) return;
    const baseDuration = toDurationMinutes(timing.duration);
    const scalingType = timing.scaling || "fixed";
    let newDuration = baseDuration;
    if (scalingType === "linear") {
      newDuration = baseDuration * multiplier;
    } else if (scalingType === "sqrt") {
      newDuration = baseDuration * Math.sqrt(multiplier);
    }
    timing.duration = Math.ceil(newDuration);
  });
}
function deepClone(value) {
  return JSON.parse(JSON.stringify(value));
}
function toDurationMinutes(duration) {
  if (typeof duration === "number" && Number.isFinite(duration)) {
    return duration;
  }
  if (typeof duration === "string" && duration.trim().startsWith("P")) {
    const parsed = parseDuration(duration.trim());
    if (parsed !== null) {
      return parsed;
    }
  }
  return 0;
}

// src/converters/yield.ts
function parseYield(value) {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (typeof value === "number") {
    return {
      amount: value,
      unit: "servings"
    };
  }
  if (Array.isArray(value)) {
    return parseYield(value[0]);
  }
  if (typeof value === "object") {
    const maybeYield = value;
    if (typeof maybeYield.amount === "number") {
      return {
        amount: maybeYield.amount,
        unit: typeof maybeYield.unit === "string" ? maybeYield.unit : "servings",
        description: typeof maybeYield.description === "string" ? maybeYield.description : void 0
      };
    }
  }
  if (typeof value === "string") {
    const trimmed = value.trim();
    const match = trimmed.match(/(\d+(?:\.\d+)?)/);
    if (match) {
      const amount = parseFloat(match[1]);
      const unit = trimmed.slice(match.index + match[1].length).trim();
      return {
        amount,
        unit: unit || "servings",
        description: trimmed
      };
    }
  }
  return void 0;
}
function formatYield(yieldValue) {
  if (!yieldValue) return void 0;
  if (!yieldValue.amount && !yieldValue.unit) {
    return void 0;
  }
  const amount = yieldValue.amount ?? "";
  const unit = yieldValue.unit ? ` ${yieldValue.unit}` : "";
  return `${amount}${unit}`.trim() || yieldValue.description;
}

// src/utils/image.ts
function normalizeImage(image) {
  if (!image) {
    return void 0;
  }
  if (typeof image === "string") {
    const trimmed = image.trim();
    return trimmed || void 0;
  }
  if (Array.isArray(image)) {
    const urls = image.map((entry) => typeof entry === "string" ? entry.trim() : extractUrl(entry)).filter((url) => typeof url === "string" && Boolean(url));
    if (urls.length === 0) {
      return void 0;
    }
    if (urls.length === 1) {
      return urls[0];
    }
    return urls;
  }
  return extractUrl(image);
}
function extractUrl(value) {
  if (!value || typeof value !== "object") {
    return void 0;
  }
  const record = value;
  const candidate = typeof record.url === "string" ? record.url : typeof record.contentUrl === "string" ? record.contentUrl : void 0;
  if (!candidate) {
    return void 0;
  }
  const trimmed = candidate.trim();
  return trimmed || void 0;
}

// src/normalize.ts
function normalizeRecipe(input) {
  if (!input || typeof input !== "object") {
    throw new Error("Recipe input must be an object");
  }
  const recipe = JSON.parse(JSON.stringify(input));
  const warnings = [];
  const legacyField = ["mod", "ules"].join("");
  if (legacyField in recipe) {
    throw new Error("The legacy field is no longer supported. Use `stacks` instead.");
  }
  normalizeStacks(recipe, warnings);
  if (!recipe.stacks) {
    recipe.stacks = {};
  }
  if (recipe && typeof recipe === "object" && "version" in recipe && !recipe.recipeVersion && typeof recipe.version === "string") {
    recipe.recipeVersion = recipe.version;
    warnings.push("'version' is deprecated; mapped to 'recipeVersion'.");
  }
  normalizeTime(recipe);
  return {
    recipe,
    warnings
  };
}
function normalizeStacks(recipe, warnings) {
  let stacks = {};
  if (recipe.stacks && typeof recipe.stacks === "object" && !Array.isArray(recipe.stacks)) {
    for (const [key, value] of Object.entries(recipe.stacks)) {
      if (typeof value === "number" && Number.isInteger(value) && value >= 1) {
        stacks[key] = value;
      } else {
        warnings.push(`Invalid stack version for '${key}': expected positive integer, got ${value}`);
      }
    }
  }
  if (Array.isArray(recipe.stacks)) {
    const stackIdentifiers = recipe.stacks.filter((s) => typeof s === "string");
    for (const identifier of stackIdentifiers) {
      const parsed = parseStackIdentifier(identifier);
      if (parsed) {
        const { name, version } = parsed;
        if (!stacks[name] || stacks[name] < version) {
          stacks[name] = version;
        }
      } else {
        warnings.push(`Invalid stack identifier '${identifier}': expected format 'name@version' (e.g., 'scaling@1')`);
      }
    }
  }
  recipe.stacks = stacks;
}
function parseStackIdentifier(identifier) {
  if (typeof identifier !== "string" || !identifier.trim()) {
    return null;
  }
  const match = identifier.trim().match(/^([a-z0-9_-]+)@(\d+)$/i);
  if (!match) {
    return null;
  }
  const [, name, versionStr] = match;
  const version = parseInt(versionStr, 10);
  if (isNaN(version) || version < 1) {
    return null;
  }
  return { name, version };
}
function normalizeTime(recipe) {
  const time = recipe?.time;
  if (!time || typeof time !== "object" || Array.isArray(time)) return;
  const structuredKeys = [
    "prep",
    "active",
    "passive",
    "total"
  ];
  structuredKeys.forEach((key) => {
    const value = time[key];
    if (typeof value === "number") return;
    const parsed = parseDuration(value);
    if (parsed !== null) {
      time[key] = parsed;
    }
  });
}

// src/fromSchemaOrg.ts
function fromSchemaOrg(input) {
  const recipeNode = extractRecipeNode(input);
  if (!recipeNode) {
    return null;
  }
  const ingredients = convertIngredients(recipeNode.recipeIngredient);
  const instructions = convertInstructions(recipeNode.recipeInstructions);
  const time = convertTime(recipeNode);
  const recipeYield = parseYield(recipeNode.recipeYield);
  const tags = collectTags(recipeNode.recipeCuisine, recipeNode.keywords);
  const category = extractFirst(recipeNode.recipeCategory);
  const source = convertSource(recipeNode);
  const dateModified = recipeNode.dateModified || void 0;
  const nutrition = convertNutrition(recipeNode.nutrition);
  const attribution = convertAttribution(recipeNode);
  const taxonomy = convertTaxonomy(tags, category, extractFirst(recipeNode.recipeCuisine));
  const media = convertMedia(recipeNode.image, recipeNode.video);
  const times = convertTimes(time);
  const stacks = {};
  if (attribution) stacks.attribution = 1;
  if (taxonomy) stacks.taxonomy = 1;
  if (media) stacks.media = 1;
  if (nutrition) stacks.nutrition = 1;
  if (times) stacks.times = 1;
  const rawRecipe = {
    "@type": "Recipe",
    profile: "minimal",
    stacks,
    name: recipeNode.name.trim(),
    description: recipeNode.description?.trim() || void 0,
    image: normalizeImage(recipeNode.image),
    category,
    tags: tags.length ? tags : void 0,
    source,
    dateAdded: recipeNode.datePublished || void 0,
    yield: recipeYield,
    time,
    ingredients,
    instructions,
    ...dateModified ? { dateModified } : {},
    ...nutrition ? { nutrition } : {},
    ...attribution ? { attribution } : {},
    ...taxonomy ? { taxonomy } : {},
    ...media ? { media } : {},
    ...times ? { times } : {}
  };
  const { recipe } = normalizeRecipe(rawRecipe);
  return recipe;
}
function extractRecipeNode(input) {
  if (!input) return null;
  if (Array.isArray(input)) {
    for (const entry of input) {
      const found = extractRecipeNode(entry);
      if (found) {
        return found;
      }
    }
    return null;
  }
  if (typeof input !== "object") {
    return null;
  }
  const record = input;
  if (record["@graph"]) {
    const fromGraph = extractRecipeNode(record["@graph"]);
    if (fromGraph) {
      return fromGraph;
    }
  }
  if (!hasRecipeType(record["@type"])) {
    return null;
  }
  if (!isValidName(record.name)) {
    return null;
  }
  return record;
}
function hasRecipeType(value) {
  if (!value) return false;
  const types = Array.isArray(value) ? value : [value];
  return types.some(
    (entry) => typeof entry === "string" && entry.toLowerCase() === "recipe"
  );
}
function isValidName(name) {
  return typeof name === "string" && Boolean(name.trim());
}
function convertIngredients(value) {
  if (!value) return [];
  const normalized = Array.isArray(value) ? value : [value];
  return normalized.map((item) => typeof item === "string" ? item.trim() : "").filter(Boolean);
}
function convertInstructions(value) {
  if (!value) return [];
  const normalized = Array.isArray(value) ? value : [value];
  const result = [];
  for (const entry of normalized) {
    if (!entry) continue;
    if (typeof entry === "string") {
      const text = entry.trim();
      if (text) {
        result.push(text);
      }
      continue;
    }
    if (isHowToSection(entry)) {
      const subsectionItems = extractSectionItems(entry.itemListElement);
      if (subsectionItems.length) {
        result.push({
          subsection: entry.name?.trim() || "Section",
          items: subsectionItems
        });
      }
      continue;
    }
    if (isHowToStep(entry)) {
      const parsed = convertHowToStep(entry);
      if (parsed) {
        result.push(parsed);
      }
    }
  }
  return result;
}
function extractSectionItems(items = []) {
  const result = [];
  for (const item of items) {
    if (!item) continue;
    if (typeof item === "string") {
      const text = item.trim();
      if (text) {
        result.push(text);
      }
      continue;
    }
    if (isHowToStep(item)) {
      const parsed = convertHowToStep(item);
      if (parsed) {
        result.push(parsed);
      }
      continue;
    }
    if (isHowToSection(item)) {
      result.push(...extractSectionItems(item.itemListElement));
    }
  }
  return result;
}
function extractInstructionText(value) {
  const text = typeof value.text === "string" ? value.text : value.name;
  return typeof text === "string" ? text.trim() || void 0 : void 0;
}
function convertHowToStep(step) {
  const text = extractInstructionText(step);
  if (!text) {
    return void 0;
  }
  const normalizedImage = normalizeImage(step.image);
  const image = Array.isArray(normalizedImage) ? normalizedImage[0] : normalizedImage;
  const id = extractInstructionId(step);
  const timing = extractInstructionTiming(step);
  if (!image && !id && !timing) {
    return text;
  }
  const instruction = { text };
  if (id) instruction.id = id;
  if (image) instruction.image = image;
  if (timing) instruction.timing = timing;
  return instruction;
}
function extractInstructionTiming(step) {
  const duration = step.totalTime || step.performTime || step.prepTime || step.duration;
  if (!duration || typeof duration !== "string") {
    return void 0;
  }
  const parsed = smartParseDuration(duration);
  return { duration: parsed ?? duration, type: "active" };
}
function extractInstructionId(step) {
  const raw = step["@id"] || step.id || step.url;
  if (typeof raw !== "string") {
    return void 0;
  }
  const trimmed = raw.trim();
  return trimmed || void 0;
}
function isHowToStep(value) {
  return Boolean(value) && typeof value === "object" && value["@type"] === "HowToStep";
}
function isHowToSection(value) {
  return Boolean(value) && typeof value === "object" && value["@type"] === "HowToSection" && Array.isArray(value.itemListElement);
}
function convertTime(recipe) {
  const prep = smartParseDuration(recipe.prepTime ?? "");
  const cook = smartParseDuration(recipe.cookTime ?? "");
  const total = smartParseDuration(recipe.totalTime ?? "");
  const structured = {};
  if (prep !== null && prep !== void 0) structured.prep = prep;
  if (cook !== null && cook !== void 0) structured.active = cook;
  if (total !== null && total !== void 0) structured.total = total;
  return Object.keys(structured).length ? structured : void 0;
}
function collectTags(cuisine, keywords) {
  const tags = /* @__PURE__ */ new Set();
  flattenStrings(cuisine).forEach((tag) => tags.add(tag));
  if (typeof keywords === "string") {
    splitKeywords(keywords).forEach((tag) => tags.add(tag));
  } else {
    flattenStrings(keywords).forEach((tag) => tags.add(tag));
  }
  return Array.from(tags);
}
function splitKeywords(value) {
  return value.split(/[,|]/).map((part) => part.trim()).filter(Boolean);
}
function flattenStrings(value) {
  if (!value) return [];
  if (typeof value === "string") return [value.trim()].filter(Boolean);
  if (Array.isArray(value)) {
    return value.map((item) => typeof item === "string" ? item.trim() : "").filter(Boolean);
  }
  return [];
}
function extractFirst(value) {
  const arr = flattenStrings(value);
  return arr.length ? arr[0] : void 0;
}
function convertSource(recipe) {
  const author = extractEntityName(recipe.author);
  const publisher = extractEntityName(recipe.publisher);
  const url = (recipe.url || recipe.mainEntityOfPage)?.trim();
  const source = {};
  if (author) source.author = author;
  if (publisher) source.name = publisher;
  if (url) source.url = url;
  return Object.keys(source).length ? source : void 0;
}
function extractEntityName(value) {
  if (!value) return void 0;
  if (typeof value === "string") {
    const trimmed = value.trim();
    return trimmed || void 0;
  }
  if (Array.isArray(value)) {
    for (const entry of value) {
      const name = extractEntityName(entry);
      if (name) {
        return name;
      }
    }
    return void 0;
  }
  if (typeof value === "object" && typeof value.name === "string") {
    const trimmed = value.name.trim();
    return trimmed || void 0;
  }
  return void 0;
}
function convertAttribution(recipe) {
  const attribution = {};
  const url = (recipe.url || recipe.mainEntityOfPage)?.trim();
  const author = extractEntityName(recipe.author);
  const datePublished = recipe.datePublished?.trim();
  if (url) attribution.url = url;
  if (author) attribution.author = author;
  if (datePublished) attribution.datePublished = datePublished;
  return Object.keys(attribution).length ? attribution : void 0;
}
function convertTaxonomy(keywords, category, cuisine) {
  const taxonomy = {};
  if (keywords.length) taxonomy.keywords = keywords;
  if (category) taxonomy.category = category;
  if (cuisine) taxonomy.cuisine = cuisine;
  return Object.keys(taxonomy).length ? taxonomy : void 0;
}
function normalizeMediaList(value) {
  if (!value) return [];
  if (typeof value === "string") return [value.trim()].filter(Boolean);
  if (Array.isArray(value)) {
    return value.map((item) => typeof item === "string" ? item.trim() : extractMediaUrl(item)).filter((entry) => Boolean(entry?.length));
  }
  const url = extractMediaUrl(value);
  return url ? [url] : [];
}
function extractMediaUrl(value) {
  if (value && typeof value === "object" && "url" in value && typeof value.url === "string") {
    const trimmed = value.url.trim();
    return trimmed || void 0;
  }
  return void 0;
}
function convertMedia(image, video) {
  const normalizedImage = normalizeImage(image);
  const images = normalizedImage ? Array.isArray(normalizedImage) ? normalizedImage : [normalizedImage] : [];
  const videos = normalizeMediaList(video);
  const media = {};
  if (images.length) media.images = images;
  if (videos.length) media.videos = videos;
  return Object.keys(media).length ? media : void 0;
}
function convertTimes(time) {
  if (!time) return void 0;
  const times = {};
  if (typeof time.prep === "number") times.prepMinutes = time.prep;
  if (typeof time.active === "number") times.cookMinutes = time.active;
  if (typeof time.total === "number") times.totalMinutes = time.total;
  return Object.keys(times).length ? times : void 0;
}
function convertNutrition(nutrition) {
  if (!nutrition || typeof nutrition !== "object") {
    return void 0;
  }
  const result = {};
  let hasData = false;
  if ("calories" in nutrition) {
    const calories = nutrition.calories;
    if (typeof calories === "number") {
      result.calories = calories;
      hasData = true;
    } else if (typeof calories === "string") {
      const parsed = parseFloat(calories.replace(/[^\d.-]/g, ""));
      if (!isNaN(parsed)) {
        result.calories = parsed;
        hasData = true;
      }
    }
  }
  if ("proteinContent" in nutrition || "protein_g" in nutrition) {
    const protein = nutrition.proteinContent || nutrition.protein_g;
    if (typeof protein === "number") {
      result.protein_g = protein;
      hasData = true;
    } else if (typeof protein === "string") {
      const parsed = parseFloat(protein.replace(/[^\d.-]/g, ""));
      if (!isNaN(parsed)) {
        result.protein_g = parsed;
        hasData = true;
      }
    }
  }
  return hasData ? result : void 0;
}

// src/schemas/registry/stacks.json
var stacks_default = {
  stacks: [
    {
      id: "attribution",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/attribution",
      schema: "http://soustack.org/schema/v0.3.0/stacks/attribution",
      schemaOrgMappable: true,
      schemaOrgConfidence: "medium",
      minProfile: "minimal",
      allowedOnMinimal: true
    },
    {
      id: "taxonomy",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/taxonomy",
      schema: "http://soustack.org/schema/v0.3.0/stacks/taxonomy",
      schemaOrgMappable: true,
      schemaOrgConfidence: "high",
      minProfile: "minimal",
      allowedOnMinimal: true
    },
    {
      id: "media",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/media",
      schema: "http://soustack.org/schema/v0.3.0/stacks/media",
      schemaOrgMappable: true,
      schemaOrgConfidence: "medium",
      minProfile: "minimal",
      allowedOnMinimal: true
    },
    {
      id: "nutrition",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/nutrition",
      schema: "http://soustack.org/schema/v0.3.0/stacks/nutrition",
      schemaOrgMappable: false,
      schemaOrgConfidence: "low",
      minProfile: "minimal",
      allowedOnMinimal: true
    },
    {
      id: "times",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/times",
      schema: "http://soustack.org/schema/v0.3.0/stacks/times",
      schemaOrgMappable: true,
      schemaOrgConfidence: "medium",
      minProfile: "minimal",
      allowedOnMinimal: true
    },
    {
      id: "schedule",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/schedule",
      schema: "http://soustack.org/schema/v0.3.0/stacks/schedule",
      schemaOrgMappable: false,
      schemaOrgConfidence: "low",
      minProfile: "core",
      allowedOnMinimal: false
    }
  ]
};

// src/converters/toSchemaOrg.ts
function convertBasicMetadata(recipe) {
  return cleanOutput({
    "@context": "https://schema.org",
    "@type": "Recipe",
    name: recipe.name,
    description: recipe.description,
    image: recipe.image,
    url: recipe.source?.url,
    datePublished: recipe.dateAdded,
    dateModified: recipe.dateModified
  });
}
function convertIngredients2(ingredients = []) {
  const result = [];
  ingredients.forEach((ingredient) => {
    if (!ingredient) {
      return;
    }
    if (typeof ingredient === "string") {
      const value2 = ingredient.trim();
      if (value2) {
        result.push(value2);
      }
      return;
    }
    if ("subsection" in ingredient) {
      ingredient.items.forEach((item) => {
        if (!item) {
          return;
        }
        if (typeof item === "string") {
          const value2 = item.trim();
          if (value2) {
            result.push(value2);
          }
        } else if (item.item) {
          const value2 = item.item.trim();
          if (value2) {
            result.push(value2);
          }
        }
      });
      return;
    }
    const value = ingredient.item?.trim();
    if (value) {
      result.push(value);
    }
  });
  return result;
}
function convertInstructions2(instructions = []) {
  return instructions.map((entry) => convertInstruction(entry)).filter((value) => Boolean(value));
}
function convertInstruction(entry) {
  if (!entry) {
    return null;
  }
  if (typeof entry === "string") {
    const value = entry.trim();
    return value || null;
  }
  if ("subsection" in entry) {
    const steps = entry.items.map((item) => convertInstruction(item)).filter((step) => Boolean(step));
    if (!steps.length) {
      return null;
    }
    return {
      "@type": "HowToSection",
      name: entry.subsection,
      itemListElement: steps
    };
  }
  if ("text" in entry) {
    return createHowToStep(entry);
  }
  return createHowToStep(String(entry));
}
function createHowToStep(entry) {
  if (!entry) return null;
  if (typeof entry === "string") {
    const trimmed2 = entry.trim();
    return trimmed2 || null;
  }
  const trimmed = entry.text?.trim();
  if (!trimmed) {
    return null;
  }
  const step = {
    "@type": "HowToStep",
    text: trimmed
  };
  if (entry.id) {
    step["@id"] = entry.id;
  }
  if (entry.timing) {
    if (typeof entry.timing.duration === "number") {
      step.performTime = formatDuration(entry.timing.duration);
    } else if (entry.timing.duration) {
      step.performTime = entry.timing.duration;
    }
  }
  if (entry.image) {
    step.image = entry.image;
  }
  if (step["@id"] || step.performTime || step.image) {
    return step;
  }
  return trimmed;
}
function convertTime2(time) {
  if (!time) {
    return {};
  }
  if (isStructuredTime(time)) {
    const result2 = {};
    if (time.prep !== void 0) {
      result2.prepTime = formatDuration(time.prep);
    }
    if (time.active !== void 0) {
      result2.cookTime = formatDuration(time.active);
    }
    if (time.total !== void 0) {
      result2.totalTime = formatDuration(time.total);
    }
    return result2;
  }
  const result = {};
  if (time.prepTime) {
    result.prepTime = time.prepTime;
  }
  if (time.cookTime) {
    result.cookTime = time.cookTime;
  }
  return result;
}
function convertTimesModule(times) {
  if (!times) {
    return {};
  }
  const result = {};
  if (times.prepMinutes !== void 0) {
    result.prepTime = formatDuration(times.prepMinutes);
  }
  if (times.cookMinutes !== void 0) {
    result.cookTime = formatDuration(times.cookMinutes);
  }
  if (times.totalMinutes !== void 0) {
    result.totalTime = formatDuration(times.totalMinutes);
  }
  return result;
}
function convertYield(yld) {
  if (!yld) {
    return void 0;
  }
  return formatYield(yld);
}
function convertAuthor(source) {
  if (!source) {
    return {};
  }
  const result = {};
  if (source.author) {
    result.author = {
      "@type": "Person",
      name: source.author
    };
  }
  if (source.name) {
    result.publisher = {
      "@type": "Organization",
      name: source.name
    };
  }
  if (source.url) {
    result.url = source.url;
  }
  return result;
}
function convertCategoryTags(category, tags) {
  const result = {};
  if (category) {
    result.recipeCategory = category;
  }
  if (tags && tags.length > 0) {
    result.keywords = tags.filter(Boolean).join(", ");
  }
  return result;
}
function convertNutrition2(nutrition) {
  if (!nutrition) {
    return void 0;
  }
  const result = {
    "@type": "NutritionInformation"
  };
  if (nutrition.calories !== void 0) {
    if (typeof nutrition.calories === "number") {
      result.calories = `${nutrition.calories} calories`;
    } else {
      result.calories = nutrition.calories;
    }
  }
  Object.keys(nutrition).forEach((key) => {
    if (key !== "calories" && key !== "@type") {
      result[key] = nutrition[key];
    }
  });
  return result;
}
function cleanOutput(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(([, value]) => value !== void 0)
  );
}
function getSchemaOrgMappableStacks(stacks = {}) {
  const mappableStackIds = /* @__PURE__ */ new Set();
  const mappableFromRegistry = stacks_default.stacks.filter((stack) => stack.schemaOrgMappable).map((stack) => `${stack.id}@${stack.latest}`);
  for (const [name, version] of Object.entries(stacks)) {
    const stackId = `${name}@${version}`;
    if (mappableFromRegistry.includes(stackId)) {
      mappableStackIds.add(stackId);
    }
  }
  return mappableStackIds;
}
function toSchemaOrg(recipe) {
  const base = convertBasicMetadata(recipe);
  const ingredients = convertIngredients2(recipe.ingredients);
  const instructions = convertInstructions2(recipe.instructions);
  const recipeStacks = recipe.stacks && typeof recipe.stacks === "object" && !Array.isArray(recipe.stacks) ? recipe.stacks : {};
  const mappableStacks = getSchemaOrgMappableStacks(recipeStacks);
  const hasMappableNutrition = mappableStacks.has("nutrition@1");
  const nutrition = hasMappableNutrition ? convertNutrition2(recipe.nutrition) : void 0;
  const hasMappableTimes = mappableStacks.has("times@1");
  const timeData = hasMappableTimes ? recipe.times ? convertTimesModule(recipe.times) : convertTime2(recipe.time) : {};
  const hasMappableAttribution = mappableStacks.has("attribution@1");
  const attributionData = hasMappableAttribution ? convertAuthor(recipe.source) : {};
  const hasMappableTaxonomy = mappableStacks.has("taxonomy@1");
  const taxonomyData = hasMappableTaxonomy ? convertCategoryTags(recipe.category, recipe.tags) : {};
  return cleanOutput({
    ...base,
    recipeIngredient: ingredients.length ? ingredients : void 0,
    recipeInstructions: instructions.length ? instructions : void 0,
    recipeYield: convertYield(recipe.yield),
    ...timeData,
    ...attributionData,
    ...taxonomyData,
    nutrition
  });
}
function isStructuredTime(time) {
  return typeof time.prep !== "undefined" || typeof time.active !== "undefined" || typeof time.passive !== "undefined" || typeof time.total !== "undefined";
}

// src/scraper/fetch.ts
var DEFAULT_USER_AGENTS = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0"
];
function chooseUserAgent(provided) {
  if (provided) return provided;
  const index = Math.floor(Math.random() * DEFAULT_USER_AGENTS.length);
  return DEFAULT_USER_AGENTS[index];
}
function resolveFetch(fetchFn) {
  if (fetchFn) {
    return fetchFn;
  }
  const globalFetch = globalThis.fetch;
  if (!globalFetch) {
    throw new Error(
      "A global fetch implementation is not available. Provide window.fetch in browsers or upgrade to Node 18+."
    );
  }
  return globalFetch;
}
function isBrowserEnvironment() {
  return typeof globalThis.document !== "undefined";
}
function isClientError(error) {
  if (typeof error.status === "number") {
    return error.status >= 400 && error.status < 500;
  }
  return error.message.includes("HTTP 4");
}
async function wait(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}
async function fetchPage(url, options = {}) {
  const {
    timeout = 1e4,
    userAgent,
    maxRetries = 2,
    fetchFn
  } = options;
  let lastError = null;
  const resolvedFetch = resolveFetch(fetchFn);
  const isBrowser2 = isBrowserEnvironment();
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    try {
      const headers = {
        Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5"
      };
      if (!isBrowser2) {
        headers["User-Agent"] = chooseUserAgent(userAgent);
      }
      const requestInit = {
        headers,
        signal: controller.signal,
        redirect: "follow"
      };
      const response = await resolvedFetch(url, requestInit);
      clearTimeout(timeoutId);
      if (response && typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
        const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
        if (ingestUrl) {
          try {
            const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
            if (globalFetch) {
              globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/fetch.ts:63", message: "fetch response", data: { url, status: response.status, statusText: response.statusText, ok: response.ok, isNYTimes: url.includes("nytimes.com") }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "B" }) }).catch(() => {
              });
            }
          } catch {
          }
        }
      }
      if (!response.ok) {
        const error = new Error(
          `HTTP ${response.status}: ${response.statusText}`
        );
        error.status = response.status;
        throw error;
      }
      const html = await response.text();
      if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
        const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
        if (ingestUrl) {
          try {
            const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
            if (globalFetch) {
              globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/fetch.ts:75", message: "HTML received", data: { htmlLength: html.length, hasLoginPage: html.toLowerCase().includes("login") || html.toLowerCase().includes("sign in"), hasRecipeData: html.includes("application/ld+json") || html.includes("schema.org/Recipe") }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "B,D" }) }).catch(() => {
              });
            }
          } catch {
          }
        }
      }
      return html;
    } catch (err) {
      clearTimeout(timeoutId);
      lastError = err instanceof Error ? err : new Error(String(err));
      if (isClientError(lastError)) {
        throw lastError;
      }
      if (attempt < maxRetries) {
        await wait(1e3 * (attempt + 1));
        continue;
      }
    }
  }
  throw lastError ?? new Error("Failed to fetch page");
}

// src/scraper/extractors/utils.ts
var RECIPE_TYPES = /* @__PURE__ */ new Set([
  "recipe",
  "https://schema.org/recipe",
  "http://schema.org/recipe"
]);
function isRecipeNode(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const type = value["@type"];
  if (typeof type === "string") {
    return RECIPE_TYPES.has(type.toLowerCase());
  }
  if (Array.isArray(type)) {
    return type.some(
      (entry) => typeof entry === "string" && RECIPE_TYPES.has(entry.toLowerCase())
    );
  }
  return false;
}
function safeJsonParse(content) {
  try {
    return JSON.parse(content);
  } catch {
    return null;
  }
}
function normalizeText(value) {
  if (!value) return void 0;
  const trimmed = value.replace(/\s+/g, " ").trim();
  return trimmed || void 0;
}

// src/scraper/extractors/jsonld.ts
function extractJsonLd(html) {
  const $ = cheerio.load(html);
  const scripts = $('script[type="application/ld+json"]');
  const candidates = [];
  scripts.each((_, element) => {
    const content = $(element).html();
    if (!content) return;
    const parsed = safeJsonParse(content);
    if (!parsed) return;
    collectCandidates(parsed, candidates);
  });
  return candidates[0] ?? null;
}
function collectCandidates(payload, bucket) {
  if (!payload) return;
  if (Array.isArray(payload)) {
    payload.forEach((entry) => collectCandidates(entry, bucket));
    return;
  }
  if (typeof payload !== "object") {
    return;
  }
  if (isRecipeNode(payload)) {
    bucket.push(payload);
    return;
  }
  const graph = payload["@graph"];
  if (Array.isArray(graph)) {
    graph.forEach((entry) => collectCandidates(entry, bucket));
  }
}
var SIMPLE_PROPS = [
  "name",
  "description",
  "image",
  "recipeYield",
  "prepTime",
  "cookTime",
  "totalTime"
];
function extractMicrodata(html) {
  const $ = cheerio.load(html);
  const recipeEl = $('[itemscope][itemtype*="schema.org/Recipe"]').first();
  if (!recipeEl.length) {
    return null;
  }
  const recipe = {
    "@type": "Recipe"
  };
  SIMPLE_PROPS.forEach((prop) => {
    const value = findPropertyValue($, recipeEl, prop);
    if (value) {
      recipe[prop] = value;
    }
  });
  const ingredients = [];
  recipeEl.find('[itemprop="recipeIngredient"]').each((_, el) => {
    const text = normalizeText($(el).attr("content") || $(el).text());
    if (text) ingredients.push(text);
  });
  if (ingredients.length) {
    recipe.recipeIngredient = ingredients;
  }
  const instructions = [];
  recipeEl.find('[itemprop="recipeInstructions"]').each((_, el) => {
    const text = normalizeText($(el).attr("content")) || normalizeText($(el).find('[itemprop="text"]').first().text()) || normalizeText($(el).text());
    if (text) instructions.push(text);
  });
  if (instructions.length) {
    recipe.recipeInstructions = instructions;
  }
  if (recipe.name || ingredients.length) {
    return recipe;
  }
  return null;
}
function findPropertyValue($, context, prop) {
  const node = context.find(`[itemprop="${prop}"]`).first();
  if (!node.length) return void 0;
  return normalizeText(node.attr("content")) || normalizeText(node.attr("href")) || normalizeText(node.attr("src")) || normalizeText(node.text());
}

// src/scraper/extractors/browser.ts
var SIMPLE_PROPS2 = ["name", "description", "image", "recipeYield", "prepTime", "cookTime", "totalTime"];
function extractRecipeBrowser(html) {
  const jsonLdRecipe = extractJsonLdBrowser(html);
  if (jsonLdRecipe) {
    return { recipe: jsonLdRecipe, source: "jsonld" };
  }
  const microdataRecipe = extractMicrodataBrowser(html);
  if (microdataRecipe) {
    return { recipe: microdataRecipe, source: "microdata" };
  }
  return { recipe: null, source: null };
}
function extractJsonLdBrowser(html) {
  if (typeof globalThis.DOMParser === "undefined") {
    return null;
  }
  const parser = new globalThis.DOMParser();
  const doc = parser.parseFromString(html, "text/html");
  const scripts = doc.querySelectorAll('script[type="application/ld+json"]');
  const candidates = [];
  scripts.forEach((script) => {
    const content = script.textContent;
    if (!content) return;
    const parsed = safeJsonParse(content);
    if (!parsed) return;
    collectCandidates2(parsed, candidates);
  });
  return candidates[0] ?? null;
}
function extractMicrodataBrowser(html) {
  if (typeof globalThis.DOMParser === "undefined") {
    return null;
  }
  const parser = new globalThis.DOMParser();
  const doc = parser.parseFromString(html, "text/html");
  const recipeEl = doc.querySelector('[itemscope][itemtype*="schema.org/Recipe"]');
  if (!recipeEl) {
    return null;
  }
  const recipe = {
    "@type": "Recipe"
  };
  SIMPLE_PROPS2.forEach((prop) => {
    const value = findPropertyValue2(recipeEl, prop);
    if (value) {
      recipe[prop] = value;
    }
  });
  const ingredients = [];
  recipeEl.querySelectorAll('[itemprop="recipeIngredient"]').forEach((el) => {
    const text = normalizeText(
      el.getAttribute("content") || el.textContent || void 0
    );
    if (text) ingredients.push(text);
  });
  if (ingredients.length) {
    recipe.recipeIngredient = ingredients;
  }
  const instructions = [];
  recipeEl.querySelectorAll('[itemprop="recipeInstructions"]').forEach((el) => {
    const text = normalizeText(el.getAttribute("content")) || normalizeText(el.querySelector('[itemprop="text"]')?.textContent || void 0) || normalizeText(el.textContent || void 0);
    if (text) instructions.push(text);
  });
  if (instructions.length) {
    recipe.recipeInstructions = instructions;
  }
  if (recipe.name || ingredients.length) {
    return recipe;
  }
  return null;
}
function findPropertyValue2(context, prop) {
  const node = context.querySelector(`[itemprop="${prop}"]`);
  if (!node) return void 0;
  return normalizeText(node.getAttribute("content")) || normalizeText(node.getAttribute("href")) || normalizeText(node.getAttribute("src")) || normalizeText(node.textContent || void 0);
}
function collectCandidates2(payload, bucket) {
  if (!payload) return;
  if (Array.isArray(payload)) {
    payload.forEach((entry) => collectCandidates2(entry, bucket));
    return;
  }
  if (typeof payload !== "object") {
    return;
  }
  if (isRecipeNode(payload)) {
    bucket.push(payload);
    return;
  }
  const graph = payload["@graph"];
  if (Array.isArray(graph)) {
    graph.forEach((entry) => collectCandidates2(entry, bucket));
  }
}

// src/scraper/extractors/index.ts
function isBrowser() {
  try {
    return typeof globalThis.DOMParser !== "undefined";
  } catch {
    return false;
  }
}
function extractRecipe(html) {
  if (isBrowser()) {
    return extractRecipeBrowser(html);
  }
  const jsonLdRecipe = extractJsonLd(html);
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/extractors/index.ts:6", message: "JSON-LD extraction result", data: { hasJsonLd: !!jsonLdRecipe }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "C,D" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  if (jsonLdRecipe) {
    return { recipe: jsonLdRecipe, source: "jsonld" };
  }
  const microdataRecipe = extractMicrodata(html);
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/extractors/index.ts:12", message: "Microdata extraction result", data: { hasMicrodata: !!microdataRecipe }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "D" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  if (microdataRecipe) {
    return { recipe: microdataRecipe, source: "microdata" };
  }
  return { recipe: null, source: null };
}

// src/scraper/index.ts
async function scrapeRecipe(url, options = {}) {
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/index.ts:7", message: "scrapeRecipe entry", data: { url, hasOptions: !!options }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "A,B,C,D,E" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  const html = await fetchPage(url, options);
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/index.ts:9", message: "HTML fetched", data: { htmlLength: html?.length, htmlPreview: html?.substring(0, 200) }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "B" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  const { recipe } = extractRecipe(html);
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/index.ts:11", message: "extractRecipe result", data: { hasRecipe: !!recipe, recipeType: recipe?.["@type"], recipeName: recipe?.name }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "A,C,D" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  if (!recipe) {
    throw new Error("No Schema.org recipe data found in page");
  }
  const soustackRecipe = fromSchemaOrg(recipe);
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/index.ts:17", message: "fromSchemaOrg result", data: { hasSoustackRecipe: !!soustackRecipe, soustackRecipeName: soustackRecipe?.name }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "A" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  if (!soustackRecipe) {
    throw new Error("Schema.org data did not include a valid recipe");
  }
  return soustackRecipe;
}

// src/conformance/index.ts
function validateConformance(recipe) {
  const issues = [];
  issues.push(...checkDAGValidity(recipe));
  if (hasSchedulableProfile(recipe)) {
    issues.push(...checkTimingSchedulability(recipe));
  }
  issues.push(...checkScalingSanity(recipe));
  const ok = issues.filter((i) => i.severity === "error").length === 0;
  return { ok, issues };
}
function hasSchedulableProfile(recipe) {
  const schema = recipe.$schema;
  if (typeof schema === "string") {
    return schema.includes("schedulable") || schema === "http://soustack.org/schema/v0.3.0/profiles/schedulable";
  }
  return false;
}
function checkDAGValidity(recipe) {
  const issues = [];
  const instructions = recipe.instructions;
  if (!Array.isArray(instructions)) {
    return issues;
  }
  const instructionIds = /* @__PURE__ */ new Set();
  const dependencyRefs = [];
  const collect = (items, basePath) => {
    items.forEach((item, index) => {
      const currentPath = `${basePath}/${index}`;
      if (isInstructionSubsection(item)) {
        if (Array.isArray(item.items)) {
          collect(item.items, `${currentPath}/items`);
        }
        return;
      }
      if (isInstruction(item)) {
        const id = typeof item.id === "string" ? item.id : void 0;
        if (id) {
          instructionIds.add(id);
        }
        if (Array.isArray(item.dependsOn)) {
          item.dependsOn.forEach((depId, depIndex) => {
            if (typeof depId === "string") {
              dependencyRefs.push({
                fromId: id,
                toId: depId,
                path: `${currentPath}/dependsOn/${depIndex}`
              });
            }
          });
        }
      }
    });
  };
  collect(instructions, "/instructions");
  dependencyRefs.forEach((ref) => {
    if (!instructionIds.has(ref.toId)) {
      issues.push({
        code: "DAG_MISSING_NODE",
        path: ref.path,
        message: `Instruction dependency references missing step id '${ref.toId}'.`,
        severity: "error"
      });
    }
  });
  const adjacency = /* @__PURE__ */ new Map();
  dependencyRefs.forEach((ref) => {
    if (ref.fromId && instructionIds.has(ref.fromId) && instructionIds.has(ref.toId)) {
      const list = adjacency.get(ref.fromId) ?? [];
      list.push({ toId: ref.toId, path: ref.path });
      adjacency.set(ref.fromId, list);
    }
  });
  const visiting = /* @__PURE__ */ new Set();
  const visited = /* @__PURE__ */ new Set();
  const detectCycles = (nodeId) => {
    if (visiting.has(nodeId)) {
      return;
    }
    if (visited.has(nodeId)) {
      return;
    }
    visiting.add(nodeId);
    const neighbors = adjacency.get(nodeId) ?? [];
    neighbors.forEach((edge) => {
      if (visiting.has(edge.toId)) {
        issues.push({
          code: "DAG_CYCLE",
          path: edge.path,
          message: `Circular dependency detected involving step id '${edge.toId}'.`,
          severity: "error"
        });
        return;
      }
      detectCycles(edge.toId);
    });
    visiting.delete(nodeId);
    visited.add(nodeId);
  };
  instructionIds.forEach((id) => detectCycles(id));
  return issues;
}
function checkTimingSchedulability(recipe) {
  const issues = [];
  const instructions = recipe.instructions;
  if (!Array.isArray(instructions)) {
    return issues;
  }
  const checkInstruction = (item, path2) => {
    if (isInstructionSubsection(item)) {
      if (Array.isArray(item.items)) {
        item.items.forEach((subItem, index) => {
          checkInstruction(subItem, `${path2}/items/${index}`);
        });
      }
      return;
    }
    if (isInstruction(item)) {
      if (!item.id) {
        issues.push({
          code: "SCHEDULABLE_MISSING_ID",
          path: path2,
          message: "Schedulable profile requires all instructions to have an id.",
          severity: "error"
        });
      }
      if (!item.timing) {
        issues.push({
          code: "SCHEDULABLE_MISSING_TIMING",
          path: path2,
          message: "Schedulable profile requires all instructions to have timing information.",
          severity: "error"
        });
      } else if (!item.timing.duration) {
        issues.push({
          code: "SCHEDULABLE_MISSING_DURATION",
          path: `${path2}/timing`,
          message: "Schedulable profile requires timing.duration for all instructions.",
          severity: "error"
        });
      }
    }
  };
  instructions.forEach((item, index) => {
    checkInstruction(item, `/instructions/${index}`);
  });
  return issues;
}
function checkScalingSanity(recipe) {
  const issues = [];
  const ingredients = recipe.ingredients;
  if (!Array.isArray(ingredients)) {
    return issues;
  }
  const ingredientIds = /* @__PURE__ */ new Set();
  const collectIngredientIds = (items, basePath) => {
    items.forEach((item, index) => {
      if (isIngredientSubsection(item)) {
        if (Array.isArray(item.items)) {
          collectIngredientIds(item.items);
        }
        return;
      }
      if (isIngredient(item)) {
        if (typeof item.id === "string") {
          ingredientIds.add(item.id);
        }
      }
    });
  };
  collectIngredientIds(ingredients);
  const checkIngredient = (item, path2) => {
    if (isIngredientSubsection(item)) {
      if (Array.isArray(item.items)) {
        item.items.forEach((subItem, index) => {
          checkIngredient(subItem, `${path2}/items/${index}`);
        });
      }
      return;
    }
    if (isIngredient(item)) {
      const scaling = item.scaling;
      if (scaling && typeof scaling === "object" && "type" in scaling && scaling.type === "bakers_percentage") {
        const bakersScaling = scaling;
        if (bakersScaling.referenceId) {
          if (!ingredientIds.has(bakersScaling.referenceId)) {
            issues.push({
              code: "SCALING_INVALID_REFERENCE",
              path: `${path2}/scaling/referenceId`,
              message: `Baker's percentage references missing ingredient id '${bakersScaling.referenceId}'.`,
              severity: "error"
            });
          }
        } else {
          issues.push({
            code: "SCALING_MISSING_REFERENCE",
            path: `${path2}/scaling`,
            message: "Baker's percentage scaling requires a referenceId.",
            severity: "error"
          });
        }
      }
    }
  };
  ingredients.forEach((item, index) => {
    checkIngredient(item, `/ingredients/${index}`);
  });
  return issues;
}
function isInstruction(item) {
  return item && typeof item === "object" && !Array.isArray(item) && "text" in item;
}
function isInstructionSubsection(item) {
  return item && typeof item === "object" && !Array.isArray(item) && "items" in item && "subsection" in item;
}
function isIngredient(item) {
  return item && typeof item === "object" && !Array.isArray(item) && "item" in item;
}
function isIngredientSubsection(item) {
  return item && typeof item === "object" && !Array.isArray(item) && "items" in item && "subsection" in item;
}

// src/soustack.schema.json
var soustack_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0",
  title: "Soustack Recipe Schema v0.3.0",
  description: "A portable, scalable, interoperable recipe format.",
  type: "object",
  required: ["name", "ingredients", "instructions"],
  additionalProperties: false,
  patternProperties: {
    "^x-": {}
  },
  properties: {
    $schema: {
      type: "string",
      format: "uri",
      description: "Optional schema hint for tooling compatibility"
    },
    id: {
      type: "string",
      description: "Unique identifier (slug or UUID)"
    },
    name: {
      type: "string",
      description: "The title of the recipe"
    },
    title: {
      type: "string",
      description: "Optional display title; alias for name"
    },
    version: {
      type: "string",
      pattern: "^\\d+\\.\\d+\\.\\d+$",
      description: "DEPRECATED: use recipeVersion for authoring revisions"
    },
    recipeVersion: {
      type: "string",
      pattern: "^\\d+\\.\\d+\\.\\d+$",
      description: "Recipe content revision (semantic versioning, e.g., 1.0.0)"
    },
    description: {
      type: "string"
    },
    category: {
      type: "string",
      examples: ["Main Course", "Dessert"]
    },
    tags: {
      type: "array",
      items: { type: "string" }
    },
    image: {
      description: "Recipe-level hero image(s)",
      anyOf: [
        {
          type: "string",
          format: "uri"
        },
        {
          type: "array",
          minItems: 1,
          items: {
            type: "string",
            format: "uri"
          }
        }
      ]
    },
    dateAdded: {
      type: "string",
      format: "date-time"
    },
    metadata: {
      type: "object",
      additionalProperties: true,
      description: "Free-form vendor metadata"
    },
    source: {
      type: "object",
      properties: {
        author: { type: "string" },
        url: { type: "string", format: "uri" },
        name: { type: "string" },
        adapted: { type: "boolean" }
      }
    },
    yield: {
      $ref: "#/definitions/yield"
    },
    time: {
      $ref: "#/definitions/time"
    },
    equipment: {
      type: "array",
      items: { $ref: "#/definitions/equipment" }
    },
    ingredients: {
      type: "array",
      items: {
        anyOf: [
          { type: "string" },
          { $ref: "#/definitions/ingredient" },
          { $ref: "#/definitions/ingredientSubsection" }
        ]
      }
    },
    instructions: {
      type: "array",
      items: {
        anyOf: [
          { type: "string" },
          { $ref: "#/definitions/instruction" },
          { $ref: "#/definitions/instructionSubsection" }
        ]
      }
    },
    storage: {
      $ref: "#/definitions/storage"
    },
    substitutions: {
      type: "array",
      items: { $ref: "#/definitions/substitution" }
    }
  },
  definitions: {
    yield: {
      type: "object",
      required: ["amount", "unit"],
      properties: {
        amount: { type: "number" },
        unit: { type: "string" },
        servings: { type: "number" },
        description: { type: "string" }
      }
    },
    time: {
      type: "object",
      properties: {
        prep: { type: "number" },
        active: { type: "number" },
        passive: { type: "number" },
        total: { type: "number" },
        prepTime: { type: "string", format: "duration" },
        cookTime: { type: "string", format: "duration" }
      },
      minProperties: 1
    },
    quantity: {
      type: "object",
      required: ["amount"],
      properties: {
        amount: { type: "number" },
        unit: {
          type: ["string", "null"],
          description: "Display-friendly unit text; implementations may normalize or canonicalize units separately."
        }
      }
    },
    scaling: {
      type: "object",
      required: ["type"],
      properties: {
        type: {
          type: "string",
          enum: ["linear", "discrete", "proportional", "fixed", "bakers_percentage"]
        },
        factor: { type: "number" },
        referenceId: { type: "string" },
        roundTo: { type: "number" },
        min: { type: "number" },
        max: { type: "number" }
      },
      if: {
        properties: { type: { const: "bakers_percentage" } }
      },
      then: {
        required: ["referenceId"]
      }
    },
    ingredient: {
      type: "object",
      required: ["item"],
      properties: {
        id: { type: "string" },
        item: { type: "string" },
        quantity: { $ref: "#/definitions/quantity" },
        name: { type: "string" },
        aisle: { type: "string" },
        prep: { type: "string" },
        prepAction: { type: "string" },
        prepActions: {
          type: "array",
          items: { type: "string" },
          description: "Structured prep verbs (e.g., peel, dice) for mise en place workflows."
        },
        prepTime: { type: "number" },
        form: {
          type: "string",
          description: "State of the ingredient as used (packed, sifted, melted, room_temperature, etc.)."
        },
        destination: { type: "string" },
        scaling: { $ref: "#/definitions/scaling" },
        critical: { type: "boolean" },
        optional: { type: "boolean" },
        notes: { type: "string" }
      }
    },
    ingredientSubsection: {
      type: "object",
      required: ["subsection", "items"],
      properties: {
        subsection: { type: "string" },
        items: {
          type: "array",
          items: { $ref: "#/definitions/ingredient" }
        }
      }
    },
    equipment: {
      type: "object",
      required: ["name"],
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        required: { type: "boolean" },
        label: { type: "string" },
        capacity: { $ref: "#/definitions/quantity" },
        scalingLimit: { type: "number" },
        alternatives: {
          type: "array",
          items: { type: "string" }
        }
      }
    },
    instruction: {
      type: "object",
      required: ["text"],
      properties: {
        id: { type: "string" },
        text: { type: "string" },
        image: {
          type: "string",
          format: "uri",
          description: "Optional image that illustrates this instruction"
        },
        destination: { type: "string" },
        dependsOn: {
          type: "array",
          items: { type: "string" }
        },
        inputs: {
          type: "array",
          items: { type: "string" }
        },
        timing: {
          type: "object",
          required: ["duration", "type"],
          properties: {
            duration: {
              anyOf: [
                { type: "number" },
                { type: "string", pattern: "^P" }
              ],
              description: "Minutes as a number or ISO8601 duration string"
            },
            type: { type: "string", enum: ["active", "passive"] },
            scaling: { type: "string", enum: ["linear", "fixed", "sqrt"] }
          }
        }
      }
    },
    instructionSubsection: {
      type: "object",
      required: ["subsection", "items"],
      properties: {
        subsection: { type: "string" },
        items: {
          type: "array",
          items: {
            anyOf: [
              { type: "string" },
              { $ref: "#/definitions/instruction" }
            ]
          }
        }
      }
    },
    storage: {
      type: "object",
      properties: {
        roomTemp: { $ref: "#/definitions/storageMethod" },
        refrigerated: { $ref: "#/definitions/storageMethod" },
        frozen: {
          allOf: [
            { $ref: "#/definitions/storageMethod" },
            {
              type: "object",
              properties: { thawing: { type: "string" } }
            }
          ]
        },
        reheating: { type: "string" },
        makeAhead: {
          type: "array",
          items: {
            allOf: [
              { $ref: "#/definitions/storageMethod" },
              {
                type: "object",
                required: ["component", "storage"],
                properties: {
                  component: { type: "string" },
                  storage: { type: "string", enum: ["roomTemp", "refrigerated", "frozen"] }
                }
              }
            ]
          }
        }
      }
    },
    storageMethod: {
      type: "object",
      required: ["duration"],
      properties: {
        duration: { type: "string", pattern: "^P" },
        method: { type: "string" },
        notes: { type: "string" }
      }
    },
    substitution: {
      type: "object",
      required: ["ingredient"],
      properties: {
        ingredient: { type: "string" },
        critical: { type: "boolean" },
        notes: { type: "string" },
        alternatives: {
          type: "array",
          items: {
            type: "object",
            required: ["name", "ratio"],
            properties: {
              name: { type: "string" },
              ratio: { type: "string" },
              notes: { type: "string" },
              impact: { type: "string" },
              dietary: {
                type: "array",
                items: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};

// src/schemas/recipe/base.schema.json
var base_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/recipe/base.schema.json",
  title: "Soustack Recipe Base Schema",
  description: "Base document shape for Soustack recipe documents. Profiles and stacks build on this baseline.",
  type: "object",
  additionalProperties: true,
  properties: {
    "@type": {
      const: "Recipe",
      description: "Document marker for Soustack recipes"
    },
    profile: {
      type: "string",
      description: "Profile identifier applied to this recipe"
    },
    stacks: {
      type: "object",
      description: "Stack declarations as a map: Record<stackName, versionNumber>",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    name: {
      type: "string",
      description: "Human-readable recipe name"
    },
    ingredients: {
      type: "array",
      description: "Ingredients payload; content is validated by profiles/stacks"
    },
    instructions: {
      type: "array",
      description: "Instruction payload; content is validated by profiles/stacks"
    }
  },
  required: ["@type"]
};

// src/schemas/recipe/profiles/minimal.schema.json
var minimal_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/recipe/profiles/minimal.schema.json",
  title: "Soustack Recipe Minimal Profile",
  description: "Minimal profile that ensures the basic Recipe structure is present while allowing stacks to extend it.",
  allOf: [
    {
      $ref: "http://soustack.org/schema/recipe/base.schema.json"
    },
    {
      type: "object",
      properties: {
        profile: {
          const: "minimal"
        },
        stacks: {
          type: "object",
          additionalProperties: {
            type: "integer",
            minimum: 1
          },
          properties: {
            attribution: { type: "integer", minimum: 1 },
            taxonomy: { type: "integer", minimum: 1 },
            media: { type: "integer", minimum: 1 },
            nutrition: { type: "integer", minimum: 1 },
            times: { type: "integer", minimum: 1 }
          }
        },
        name: {
          type: "string",
          minLength: 1
        },
        ingredients: {
          type: "array",
          minItems: 1
        },
        instructions: {
          type: "array",
          minItems: 1
        }
      },
      required: [
        "profile",
        "name",
        "ingredients",
        "instructions"
      ],
      additionalProperties: true
    }
  ]
};

// src/schemas/recipe/profiles/core.schema.json
var core_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/recipe/profiles/core.schema.json",
  title: "Soustack Recipe Core Profile",
  description: "Core profile that builds on the minimal profile and is intended to be combined with recipe stacks.",
  allOf: [
    { $ref: "http://soustack.org/schema/recipe/base.schema.json" },
    {
      type: "object",
      properties: {
        profile: { const: "core" },
        stacks: {
          type: "object",
          additionalProperties: {
            type: "integer",
            minimum: 1
          }
        },
        name: { type: "string", minLength: 1 },
        ingredients: { type: "array", minItems: 1 },
        instructions: { type: "array", minItems: 1 }
      },
      required: ["profile", "name", "ingredients", "instructions"],
      additionalProperties: true
    }
  ]
};

// spec/profiles/base.schema.json
var base_schema_default2 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/base",
  title: "Soustack Base Profile Schema",
  description: "Wrapper schema that exposes the unmodified Soustack base schema.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" }
  ]
};

// spec/profiles/cookable.schema.json
var cookable_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/cookable",
  title: "Soustack Cookable Profile Schema",
  description: "Extends the base schema to require structured yield + time metadata and non-empty ingredient/instruction lists.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" },
    {
      required: ["yield", "time", "ingredients", "instructions"],
      properties: {
        yield: { $ref: "http://soustack.org/schema/v0.3.0#/definitions/yield" },
        time: { $ref: "http://soustack.org/schema/v0.3.0#/definitions/time" },
        ingredients: { type: "array", minItems: 1 },
        instructions: { type: "array", minItems: 1 }
      }
    }
  ]
};

// spec/profiles/illustrated.schema.json
var illustrated_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/illustrated",
  title: "Soustack Illustrated Profile Schema",
  description: "Extends the base schema to guarantee at least one illustrative image.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" },
    {
      anyOf: [
        { required: ["image"] },
        {
          properties: {
            instructions: {
              type: "array",
              contains: {
                anyOf: [
                  { $ref: "#/definitions/imageInstruction" },
                  { $ref: "#/definitions/instructionSubsectionWithImage" }
                ]
              }
            }
          }
        }
      ]
    }
  ],
  definitions: {
    imageInstruction: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/instruction" },
        { required: ["image"] }
      ]
    },
    instructionSubsectionWithImage: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/instructionSubsection" },
        {
          properties: {
            items: {
              type: "array",
              contains: { $ref: "#/definitions/imageInstruction" }
            }
          }
        }
      ]
    }
  }
};

// spec/profiles/quantified.schema.json
var quantified_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/quantified",
  title: "Soustack Quantified Profile Schema",
  description: "Extends the base schema to require quantified ingredient entries.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" },
    {
      properties: {
        ingredients: {
          type: "array",
          items: {
            anyOf: [
              { $ref: "#/definitions/quantifiedIngredient" },
              { $ref: "#/definitions/quantifiedIngredientSubsection" }
            ]
          }
        }
      }
    }
  ],
  definitions: {
    quantifiedIngredient: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/ingredient" },
        { required: ["item", "quantity"] }
      ]
    },
    quantifiedIngredientSubsection: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/ingredientSubsection" },
        {
          properties: {
            items: {
              type: "array",
              items: { $ref: "#/definitions/quantifiedIngredient" }
            }
          }
        }
      ]
    }
  }
};

// spec/profiles/scalable.schema.json
var scalable_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/scalable",
  title: "Soustack Scalable Profile Schema",
  description: "Extends the base schema to guarantee quantified ingredients plus a structured yield for deterministic scaling.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" },
    {
      required: ["yield", "ingredients"],
      properties: {
        yield: {
          allOf: [
            { $ref: "http://soustack.org/schema/v0.3.0#/definitions/yield" },
            { properties: { amount: { type: "number", exclusiveMinimum: 0 } } }
          ]
        },
        ingredients: {
          type: "array",
          minItems: 1,
          items: {
            anyOf: [
              { $ref: "#/definitions/scalableIngredient" },
              { $ref: "#/definitions/scalableIngredientSubsection" }
            ]
          }
        }
      }
    }
  ],
  definitions: {
    scalableIngredient: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/ingredient" },
        { required: ["item", "quantity"] },
        {
          properties: {
            quantity: {
              allOf: [
                { $ref: "http://soustack.org/schema/v0.3.0#/definitions/quantity" },
                { properties: { amount: { type: "number", exclusiveMinimum: 0 } } }
              ]
            }
          }
        },
        {
          if: {
            properties: {
              scaling: {
                type: "object",
                properties: { type: { const: "bakers_percentage" } },
                required: ["type"]
              }
            },
            required: ["scaling"]
          },
          then: { required: ["id"] }
        }
      ]
    },
    scalableIngredientSubsection: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/ingredientSubsection" },
        {
          properties: {
            items: {
              type: "array",
              minItems: 1,
              items: { $ref: "#/definitions/scalableIngredient" }
            }
          }
        }
      ]
    }
  }
};

// spec/profiles/schedulable.schema.json
var schedulable_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/schedulable",
  title: "Soustack Schedulable Profile Schema",
  description: "Extends the base schema to ensure every instruction is fully scheduled.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" },
    {
      properties: {
        instructions: {
          type: "array",
          items: {
            anyOf: [
              { $ref: "#/definitions/schedulableInstruction" },
              { $ref: "#/definitions/schedulableInstructionSubsection" }
            ]
          }
        }
      }
    }
  ],
  definitions: {
    schedulableInstruction: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/instruction" },
        { required: ["id", "timing"] }
      ]
    },
    schedulableInstructionSubsection: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/instructionSubsection" },
        {
          properties: {
            items: {
              type: "array",
              items: { $ref: "#/definitions/schedulableInstruction" }
            }
          }
        }
      ]
    }
  }
};

// src/schemas/recipe/stacks/attribution/1.schema.json
var schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/attribution/1.schema.json",
  title: "Soustack Recipe Stack: attribution v1",
  description: "Schema for the attribution stack. Ensures namespace data is present when the stack is enabled and vice versa.",
  type: "object",
  properties: {
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    attribution: {
      type: "object",
      properties: {
        url: { type: "string" },
        author: { type: "string" },
        datePublished: { type: "string" }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              attribution: { const: 1 }
            },
            required: ["attribution"]
          }
        }
      },
      then: {
        required: ["attribution"]
      }
    },
    {
      if: {
        required: ["attribution"]
      },
      then: {
        required: ["stacks"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              attribution: { const: 1 }
            },
            required: ["attribution"]
          }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/schemas/recipe/stacks/media/1.schema.json
var schema_default2 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/media/1.schema.json",
  title: "Soustack Recipe Stack: media v1",
  description: "Schema for the media stack. Guards media blocks based on stack activation and ensures declarations accompany payloads.",
  type: "object",
  properties: {
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    media: {
      type: "object",
      properties: {
        images: { type: "array", items: { type: "string" } },
        videos: { type: "array", items: { type: "string" } }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              media: { const: 1 }
            },
            required: ["media"]
          }
        }
      },
      then: {
        required: ["media"]
      }
    },
    {
      if: {
        required: ["media"]
      },
      then: {
        required: ["stacks"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              media: { const: 1 }
            },
            required: ["media"]
          }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/schemas/recipe/stacks/nutrition/1.schema.json
var schema_default3 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/nutrition/1.schema.json",
  title: "Soustack Recipe Stack: nutrition v1",
  description: "Schema for the nutrition stack. Keeps nutrition data aligned with stack declarations and vice versa.",
  type: "object",
  properties: {
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    nutrition: {
      type: "object",
      properties: {
        calories: { type: "number" },
        protein_g: { type: "number" }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              nutrition: { const: 1 }
            },
            required: ["nutrition"]
          }
        }
      },
      then: {
        required: ["nutrition"]
      }
    },
    {
      if: {
        required: ["nutrition"]
      },
      then: {
        required: ["stacks"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              nutrition: { const: 1 }
            },
            required: ["nutrition"]
          }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/schemas/recipe/stacks/schedule/1.schema.json
var schema_default4 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/schedule/1.schema.json",
  title: "Soustack Recipe Stack: schedule v1",
  description: "Schema for the schedule stack. Enforces bidirectional stack gating and restricts usage to the core profile.",
  type: "object",
  properties: {
    profile: { type: "string" },
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    schedule: {
      type: "object",
      properties: {
        tasks: { type: "array" }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              schedule: { const: 1 }
            },
            required: ["schedule"]
          }
        }
      },
      then: {
        required: ["schedule", "profile"],
        properties: {
          profile: { const: "core" }
        }
      }
    },
    {
      if: {
        required: ["schedule"]
      },
      then: {
        required: ["stacks", "profile"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              schedule: { const: 1 }
            },
            required: ["schedule"]
          },
          profile: { const: "core" }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/schemas/recipe/stacks/taxonomy/1.schema.json
var schema_default5 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/taxonomy/1.schema.json",
  title: "Soustack Recipe Stack: taxonomy v1",
  description: "Schema for the taxonomy stack. Enforces keyword and categorization data when enabled and ensures stack declaration accompanies the namespace block.",
  type: "object",
  properties: {
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    taxonomy: {
      type: "object",
      properties: {
        keywords: { type: "array", items: { type: "string" } },
        category: { type: "string" },
        cuisine: { type: "string" }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              taxonomy: { const: 1 }
            },
            required: ["taxonomy"]
          }
        }
      },
      then: {
        required: ["taxonomy"]
      }
    },
    {
      if: {
        required: ["taxonomy"]
      },
      then: {
        required: ["stacks"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              taxonomy: { const: 1 }
            },
            required: ["taxonomy"]
          }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/schemas/recipe/stacks/times/1.schema.json
var schema_default6 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/times/1.schema.json",
  title: "Soustack Recipe Stack: times v1",
  description: "Schema for the times stack. Maintains alignment between stack declarations and timing payloads.",
  type: "object",
  properties: {
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    times: {
      type: "object",
      properties: {
        prepMinutes: { type: "number" },
        cookMinutes: { type: "number" },
        totalMinutes: { type: "number" }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              times: { const: 1 }
            },
            required: ["times"]
          }
        }
      },
      then: {
        required: ["times"]
      }
    },
    {
      if: {
        required: ["times"]
      },
      then: {
        required: ["stacks"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              times: { const: 1 }
            },
            required: ["times"]
          }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/validator.ts
var LEGACY_ROOT_SCHEMA_ID = "http://soustack.org/schema/v0.3.0";
var DEFAULT_ROOT_SCHEMA_ID = "https://soustack.spec/soustack.schema.json";
var BASE_SCHEMA_ID = "http://soustack.org/schema/recipe/base.schema.json";
var PROFILE_SCHEMA_PREFIX = "http://soustack.org/schema/recipe/profiles/";
var validationContexts = /* @__PURE__ */ new Map();
function loadAllSchemas(ajv) {
  const schemas = [
    soustack_schema_default,
    base_schema_default,
    minimal_schema_default,
    core_schema_default,
    base_schema_default2,
    cookable_schema_default,
    illustrated_schema_default,
    quantified_schema_default,
    scalable_schema_default,
    schedulable_schema_default,
    schema_default,
    schema_default2,
    schema_default3,
    schema_default4,
    schema_default5,
    schema_default6
  ];
  for (const schema of schemas) {
    if (schema && typeof schema === "object" && "$id" in schema) {
      const schemaWithId = schema;
      if (schemaWithId.$id) {
        ajv.addSchema(schemaWithId, schemaWithId.$id);
      }
    }
  }
  ajv.addSchema(
    {
      $id: DEFAULT_ROOT_SCHEMA_ID,
      allOf: [
        { $ref: LEGACY_ROOT_SCHEMA_ID },
        {
          type: "object",
          properties: {
            $schema: { const: DEFAULT_ROOT_SCHEMA_ID }
          }
        }
      ]
    },
    DEFAULT_ROOT_SCHEMA_ID
  );
}
function createContext(collectAllErrors) {
  const ajv = new Ajv2020__default.default({
    strict: false,
    allErrors: collectAllErrors,
    validateSchema: false
    // Don't validate schemas themselves
  });
  addFormats__default.default(ajv);
  loadAllSchemas(ajv);
  const rootValidator = ajv.getSchema(DEFAULT_ROOT_SCHEMA_ID) || ajv.getSchema(LEGACY_ROOT_SCHEMA_ID);
  const baseValidator = ajv.getSchema(BASE_SCHEMA_ID);
  return {
    ajv,
    rootValidator: rootValidator || void 0,
    baseValidator: baseValidator || void 0,
    validators: /* @__PURE__ */ new Map()
  };
}
function getContext(collectAllErrors) {
  if (!validationContexts.has(collectAllErrors)) {
    validationContexts.set(collectAllErrors, createContext(collectAllErrors));
  }
  return validationContexts.get(collectAllErrors);
}
function cloneRecipe(recipe) {
  if (typeof structuredClone === "function") {
    return structuredClone(recipe);
  }
  return JSON.parse(JSON.stringify(recipe));
}
function formatAjvError(error) {
  let path2 = error.instancePath || "/";
  if (error.keyword === "additionalProperties" && error.params?.additionalProperty) {
    const extra = error.params.additionalProperty;
    path2 = `${error.instancePath || ""}/${extra}`.replace(/\/+/g, "/") || "/";
  }
  return {
    path: path2,
    keyword: error.keyword,
    message: error.message || "Validation error"
  };
}
function isSoustackSchemaId(schemaId) {
  return schemaId.startsWith("http://soustack.org/schema") || schemaId.startsWith("https://soustack.org/schema") || schemaId.startsWith("https://soustack.spec/") || schemaId.startsWith("https://soustack.org/schemas/");
}
function inferStacksFromPayload(recipe) {
  const inferred = {};
  const payloadToStack = {
    attribution: "attribution",
    taxonomy: "taxonomy",
    media: "media",
    times: "times",
    nutrition: "nutrition",
    schedule: "schedule"
  };
  for (const [field, stackName] of Object.entries(payloadToStack)) {
    if (recipe && typeof recipe === "object" && field in recipe && recipe[field] !== void 0) {
      inferred[stackName] = 1;
    }
  }
  return inferred;
}
function getComposedValidator(profile, stacks, context) {
  const stackIdentifiers = Object.entries(stacks).map(([name, version]) => `${name}@${version}`).sort();
  const cacheKey = `${profile}::${stackIdentifiers.join(",")}`;
  const cached = context.validators.get(cacheKey);
  if (cached) return cached;
  const allOf = [{ $ref: BASE_SCHEMA_ID }];
  if (!context.ajv.getSchema(BASE_SCHEMA_ID)) {
    throw new Error(`Base schema not loaded: ${BASE_SCHEMA_ID}. Ensure schemas are loaded before creating validators.`);
  }
  const profileSchemaId = `${PROFILE_SCHEMA_PREFIX}${profile}.schema.json`;
  if (!context.ajv.getSchema(profileSchemaId)) {
    throw new Error(`Profile schema not loaded: ${profileSchemaId}`);
  }
  allOf.push({ $ref: profileSchemaId });
  for (const [name, version] of Object.entries(stacks)) {
    if (typeof version === "number" && version >= 1) {
      const stackSchemaId = `https://soustack.org/schemas/recipe/stacks/${name}/${version}.schema.json`;
      if (!context.ajv.getSchema(stackSchemaId)) {
        throw new Error(`Stack schema not loaded: ${stackSchemaId}`);
      }
      allOf.push({ $ref: stackSchemaId });
    }
  }
  const composedSchema = {
    $id: `urn:soustack:composed:${cacheKey}`,
    allOf
  };
  const validateFn = context.ajv.compile(composedSchema);
  context.validators.set(cacheKey, validateFn);
  return validateFn;
}
function validateRecipeSchemaNormalized(normalizedInput, inputHasStacks, collectAllErrors, schemaOverride) {
  const normalized = cloneRecipe(normalizedInput);
  const context = getContext(collectAllErrors);
  const schemaId = typeof schemaOverride === "string" ? schemaOverride : typeof normalized.$schema === "string" ? normalized.$schema : void 0;
  const hasSchemaOverride = typeof schemaOverride === "string";
  const isSoustackSchema = schemaId ? isSoustackSchemaId(schemaId) : false;
  if (schemaId && isSoustackSchema) {
    const schemaValidator = context.ajv.getSchema(schemaId);
    if (!schemaValidator) {
      return {
        ok: false,
        errors: [
          {
            path: "/$schema",
            message: `Unknown schema: ${schemaId}`
          }
        ]
      };
    }
    const schemaInput = cloneRecipe(normalized);
    if (hasSchemaOverride && "$schema" in schemaInput && schemaInput.$schema !== schemaId) {
      delete schemaInput.$schema;
    }
    const isLegacySchema = schemaId.startsWith(LEGACY_ROOT_SCHEMA_ID);
    const shouldRemoveStacks = (isLegacySchema || schemaId === DEFAULT_ROOT_SCHEMA_ID) && !inputHasStacks;
    if (isLegacySchema && "@type" in schemaInput) {
      delete schemaInput["@type"];
    }
    if (shouldRemoveStacks && "stacks" in schemaInput) {
      delete schemaInput.stacks;
    }
    const schemaValid = schemaValidator(schemaInput);
    const schemaErrors = schemaValidator.errors || [];
    return {
      ok: !!schemaValid,
      errors: schemaErrors.map(formatAjvError)
    };
  }
  const hasProfile = normalized.profile && typeof normalized.profile === "string";
  let declaredStacks = {};
  if (normalized.stacks && typeof normalized.stacks === "object" && !Array.isArray(normalized.stacks)) {
    for (const [name, version] of Object.entries(normalized.stacks)) {
      if (typeof version === "number" && version >= 1) {
        declaredStacks[name] = version;
      }
    }
  }
  const inferredStacks = inferStacksFromPayload(normalized);
  const allStacks = { ...declaredStacks };
  for (const [name, version] of Object.entries(inferredStacks)) {
    if (!allStacks[name] || allStacks[name] < version) {
      allStacks[name] = version;
    }
  }
  let isValid;
  let errors = [];
  const profile = hasProfile ? normalized.profile.toLowerCase() : "core";
  const profileSchemaId = `${PROFILE_SCHEMA_PREFIX}${profile}.schema.json`;
  if (!context.ajv.getSchema(profileSchemaId)) {
    return {
      ok: false,
      errors: [
        {
          path: "/profile",
          message: `Profile schema not loaded: ${profileSchemaId}`
        }
      ]
    };
  }
  {
    const validationCopy = cloneRecipe(normalized);
    if (!validationCopy.stacks || typeof validationCopy.stacks !== "object" || Array.isArray(validationCopy.stacks)) {
      validationCopy.stacks = declaredStacks;
    }
    if (!validationCopy.profile) {
      validationCopy.profile = profile;
    }
    const validator = getComposedValidator(profile, allStacks, context);
    isValid = validator(validationCopy);
    errors = validator.errors || [];
    if (isValid && context.rootValidator) {
      const rootCheckCopy = cloneRecipe(normalized);
      if ("@type" in rootCheckCopy) {
        delete rootCheckCopy["@type"];
      }
      if ("stacks" in rootCheckCopy) {
        delete rootCheckCopy.stacks;
      }
      if ("profile" in rootCheckCopy) {
        delete rootCheckCopy.profile;
      }
      const stackPayloadFields = ["attribution", "taxonomy", "media", "times", "nutrition", "schedule"];
      for (const field of stackPayloadFields) {
        if (field in rootCheckCopy) {
          delete rootCheckCopy[field];
        }
      }
      const rootValid = context.rootValidator(rootCheckCopy);
      if (!rootValid && context.rootValidator.errors) {
        const unknownKeyErrors = context.rootValidator.errors.filter(
          (e) => e.keyword === "additionalProperties" && (e.instancePath === "" || e.instancePath === "/")
        );
        const schemaConstErrors = context.rootValidator.errors.filter(
          (e) => e.keyword === "const" && e.instancePath === "/$schema"
        );
        const relevantErrors = [...unknownKeyErrors, ...schemaConstErrors];
        if (relevantErrors.length > 0) {
          errors.push(...relevantErrors);
          isValid = false;
        }
      }
    }
  }
  return {
    ok: isValid,
    errors: errors.map(formatAjvError)
  };
}
function validateRecipe(input, options = {}) {
  const { recipe: normalized, warnings } = normalizeRecipe(input);
  if (options.profile) {
    normalized.profile = options.profile;
  }
  const inputHasStacks = !!input && typeof input === "object" && !Array.isArray(input) && "stacks" in input;
  const { ok: schemaOk, errors: schemaErrors } = validateRecipeSchemaNormalized(
    normalized,
    inputHasStacks,
    options.collectAllErrors ?? true,
    options.schema
  );
  const mode = options.mode ?? "full";
  let conformanceIssues = [];
  let conformanceOk = true;
  if (mode === "full") {
    if (schemaOk) {
      const conformanceResult = validateConformance(normalized);
      conformanceIssues = conformanceResult.issues;
      conformanceOk = conformanceResult.ok;
    } else {
      conformanceOk = false;
    }
  }
  const ok = schemaOk && (mode === "schema" ? true : conformanceOk);
  const normalizedRecipe = ok || options.includeNormalized ? normalized : void 0;
  return {
    ok,
    schemaErrors,
    conformanceIssues,
    warnings,
    normalizedRecipe
  };
}

// bin/cli.ts
var supportedProfiles = [
  "base",
  "equipped",
  "illustrated",
  "lite",
  "prepped",
  "scalable",
  "timed"
];
async function runCli(argv) {
  const [command, ...args] = argv;
  try {
    switch (command) {
      case "check":
        await handleCheck(args);
        return;
      case "validate":
        await handleValidate(args);
        return;
      case "convert":
        await handleConvert(args);
        return;
      case "import":
        await handleImport(args);
        return;
      case "scale":
        await handleScale(args);
        return;
      case "scrape":
        await handleScrape(args);
        return;
      case "test":
        await handleTest(args);
        return;
      default:
        printUsage();
        process.exitCode = 1;
    }
  } catch (error) {
    console.error(`\u274C ${error?.message ?? error}`);
    process.exit(1);
  }
}
function printUsage() {
  console.log("Usage:");
  console.log("  soustack check <file> --json");
  console.log(
    "  soustack validate <fileOrGlob> [--profile <name>] [--force-profile] [--schema-only] [--strict] [--json]"
  );
  console.log("  soustack convert --from <schemaorg|soustack> --to <schemaorg|soustack> <input> [-o <output>]");
  console.log("  soustack import --url <url> [-o <soustack.json>]");
  console.log("  soustack test [--profile <name>] [--force-profile] [--schema-only] [--strict] [--json]");
  console.log("  soustack scale <soustack.json> <multiplier>");
  console.log("  soustack scrape <url> -o <soustack.json>");
  console.log(`
Profiles: ${supportedProfiles.join(", ")}`);
}
async function handleCheck(args) {
  const { target, json } = parseCheckArgs(args);
  if (!target) throw new Error("Path to Soustack recipe JSON is required");
  if (!json) throw new Error("Check usage: check <file> --json");
  try {
    const input = readJsonFile(target);
    const result = validateRecipe(input, { mode: "full", includeNormalized: true });
    const report = buildConformanceReport(result);
    console.log(JSON.stringify(report, null, 2));
    if (!report.ok) process.exitCode = 1;
  } catch (error) {
    const report = buildConformanceReport({
      ok: false,
      warnings: [],
      schemaErrors: [{ path: "/", message: error?.message || "Validation failed" }],
      conformanceIssues: [],
      normalizedRecipe: void 0
    });
    console.log(JSON.stringify(report, null, 2));
    process.exitCode = 1;
  }
}
async function handleValidate(args) {
  const { target, profile, forceProfile, strict, json, mode } = parseValidateArgs(args);
  if (!target) throw new Error("Path or glob to Soustack recipe JSON is required");
  const files = expandTargets(target);
  if (files.length === 0) throw new Error(`No files matched pattern: ${target}`);
  const results = files.map((file) => validateFile(file, profile, mode, forceProfile));
  reportValidation(results, { strict, json});
}
async function handleTest(args) {
  const { profile, forceProfile, strict, json, mode } = parseValidationFlags(args);
  const cwd = process.cwd();
  const files = glob.globSync("**/*.soustack.json", {
    cwd,
    absolute: true,
    nodir: true,
    ignore: ["**/node_modules/**", "**/dist/**", "**/build/**", "**/.git/**"]
  }).map((file) => path__namespace.resolve(cwd, file));
  if (files.length === 0) {
    console.log("No *.soustack.json files found in the current repository.");
    return;
  }
  const results = files.map((file) => validateFile(file, profile, mode, forceProfile));
  reportValidation(results, { strict, json, context: "test" });
}
async function handleConvert(args) {
  const { from, to, inputPath, outputPath } = parseConvertArgs(args);
  const fromKey = from?.toLowerCase();
  const toKey = to?.toLowerCase();
  if (!inputPath || !fromKey || !toKey) {
    throw new Error("Convert usage: convert --from <schemaorg|soustack> --to <schemaorg|soustack> <input> [-o <output>]");
  }
  const direction = resolveConvertDirection(fromKey, toKey);
  if (!direction) {
    throw new Error(`Unsupported conversion from "${from}" to "${to}"`);
  }
  const input = readJsonFile(inputPath);
  const result = direction === "schemaorg-to-soustack" ? fromSchemaOrg(input) : toSchemaOrg(input);
  if (!result) {
    throw new Error("Unable to convert input with the provided formats.");
  }
  writeOutput(result, outputPath);
  console.log(`\u2705 Converted ${fromKey} \u2192 ${toKey}${outputPath ? ` (${outputPath})` : ""}`);
}
async function handleImport(args) {
  const { url, outputPath } = parseImportArgs(args);
  if (!url) throw new Error("Import usage: import --url <url> [-o <soustack.json>]");
  const recipe = await scrapeRecipe(url);
  writeOutput(recipe, outputPath);
  console.log(`\u2705 Imported recipe from ${url}${outputPath ? ` (${outputPath})` : ""}`);
}
async function handleScale(args) {
  const filePath = args[0];
  const multiplier = args[1] ? parseFloat(args[1]) : 1;
  if (!filePath || Number.isNaN(multiplier)) {
    throw new Error("Scale usage: scale <soustack.json> <multiplier>");
  }
  const recipe = readJsonFile(filePath);
  console.log(`
\u2696\uFE0F  Scaling "${recipe?.name ?? filePath}" by ${multiplier}x...
`);
  const result = scaleRecipe(recipe, { multiplier });
  console.log(JSON.stringify(result, null, 2));
}
async function handleScrape(args) {
  const url = args[0];
  const outputPath = resolveOutputPath(args.slice(1));
  if (!url) throw new Error("Scrape usage: scrape <url> -o <soustack.json>");
  const recipe = await scrapeRecipe(url);
  writeOutput(recipe, outputPath);
  console.log(`\u2705 Scraped recipe from ${url}${outputPath ? ` (${outputPath})` : ""}`);
}
function parseValidateArgs(args) {
  let profile;
  let forceProfile = false;
  let strict = false;
  let json = false;
  let mode = "full";
  let target;
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    switch (arg) {
      case "--profile":
        profile = normalizeProfile(args[i + 1]);
        i++;
        break;
      case "--force-profile":
        forceProfile = true;
        break;
      case "--schema-only":
        mode = "schema";
        break;
      case "--strict":
        strict = true;
        break;
      case "--json":
        json = true;
        break;
      default:
        if (!arg.startsWith("--") && !target) {
          target = arg;
        }
        break;
    }
  }
  return { profile, forceProfile, strict, json, mode, target };
}
function parseCheckArgs(args) {
  let json = false;
  let target;
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === "--json") {
      json = true;
      continue;
    }
    if (!arg.startsWith("--") && !target) {
      target = arg;
    }
  }
  return { target, json };
}
function parseValidationFlags(args) {
  const { profile, forceProfile, strict, json, mode } = parseValidateArgs(args);
  return { profile, forceProfile, strict, json, mode };
}
function normalizeProfile(value) {
  if (!value) return void 0;
  const normalized = value.toLowerCase();
  if (supportedProfiles.includes(normalized)) {
    return normalized;
  }
  throw new Error(`Unknown Soustack profile: ${value}. Supported profiles: ${supportedProfiles.join(", ")}`);
}
function parseConvertArgs(args) {
  let from;
  let to;
  let outputPath;
  let inputPath;
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    switch (arg) {
      case "--from":
        from = args[i + 1];
        if (!from) throw new Error("Missing value for --from");
        i++;
        break;
      case "--to":
        to = args[i + 1];
        if (!to) throw new Error("Missing value for --to");
        i++;
        break;
      case "-o":
      case "--output":
        outputPath = args[i + 1];
        if (!outputPath) throw new Error("Missing value for output");
        i++;
        break;
      default:
        if (!inputPath && !arg.startsWith("--")) {
          inputPath = arg;
        }
        break;
    }
  }
  return { from, to, inputPath, outputPath };
}
function parseImportArgs(args) {
  let url;
  let outputPath;
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === "--url") {
      url = args[i + 1];
      if (!url) {
        throw new Error("URL flag provided without a value");
      }
      i++;
    } else if (arg === "-o" || arg === "--output") {
      outputPath = args[i + 1];
      if (!outputPath) {
        throw new Error("Output flag provided without a path");
      }
      i++;
    }
  }
  return { url, outputPath };
}
function resolveConvertDirection(from, to) {
  if (from === "schemaorg" && to === "soustack") return "schemaorg-to-soustack";
  if (from === "soustack" && to === "schemaorg") return "soustack-to-schemaorg";
  return null;
}
function expandTargets(target) {
  const matches = glob.globSync(target, { absolute: true, nodir: true });
  const unique = Array.from(new Set(matches.map((match) => path__namespace.resolve(match))));
  return unique;
}
function validateFile(file, profile, mode = "full", forceProfile = false) {
  try {
    const recipe = readJsonFile(file);
    const { recipe: validationRecipe, mismatchError } = resolveProfileForValidation(recipe, profile, forceProfile);
    if (mismatchError) {
      return {
        file,
        profile,
        ok: false,
        warnings: [],
        schemaErrors: [mismatchError],
        conformanceIssues: []
      };
    }
    const result = validateRecipe(validationRecipe, profile ? { profile, mode } : { mode });
    return {
      file,
      profile,
      ok: result.ok,
      warnings: result.warnings,
      schemaErrors: result.schemaErrors,
      conformanceIssues: result.conformanceIssues
    };
  } catch (error) {
    return {
      file,
      profile,
      ok: false,
      warnings: [],
      schemaErrors: [{ path: "/", message: error?.message || "Validation failed", keyword: "error" }],
      conformanceIssues: []
    };
  }
}
function resolveProfileForValidation(recipe, profile, forceProfile = false) {
  if (!profile) return { recipe };
  if (!recipe || typeof recipe !== "object" || Array.isArray(recipe)) {
    return { recipe };
  }
  const recipeProfileRaw = recipe.profile;
  const recipeProfile = typeof recipeProfileRaw === "string" ? recipeProfileRaw.toLowerCase() : void 0;
  if (!recipeProfile) {
    return { recipe: { ...recipe, profile } };
  }
  if (recipeProfile !== profile) {
    if (!forceProfile) {
      return {
        recipe,
        mismatchError: {
          path: "/profile",
          keyword: "profile",
          message: `Recipe profile "${recipeProfile}" does not match --profile "${profile}". Use --force-profile to override.`
        }
      };
    }
    return { recipe: { ...recipe, profile } };
  }
  return { recipe };
}
function reportValidation(results, options) {
  const summary = {
    strict: options.strict,
    total: results.length,
    passed: 0,
    failed: 0
  };
  const serializable = results.map((result) => {
    const passed = isEffectivelyValid(result, options.strict);
    if (passed) summary.passed += 1;
    else summary.failed += 1;
    return {
      file: path__namespace.relative(process.cwd(), result.file),
      profile: result.profile,
      ok: result.ok,
      warnings: result.warnings,
      schemaErrors: result.schemaErrors,
      conformanceIssues: result.conformanceIssues,
      passed
    };
  });
  if (options.json) {
    console.log(JSON.stringify({ summary, results: serializable }, null, 2));
  } else {
    serializable.forEach((entry) => {
      const prefix = entry.passed ? "\u2705" : "\u274C";
      console.log(`${prefix} ${entry.file}`);
      if (!entry.passed && entry.schemaErrors.length) {
        console.log("   Schema errors:");
        entry.schemaErrors.forEach((error) => {
          console.log(`   \u2022 [${error.path}] ${error.message}`);
        });
      }
      if (!entry.passed && entry.conformanceIssues.length) {
        console.log("   Conformance issues:");
        entry.conformanceIssues.forEach((issue) => {
          console.log(`   \u2022 [${issue.path}] ${issue.message} (${issue.code})`);
        });
      }
      if (!entry.passed && options.strict && entry.warnings.length) {
        console.log("   Warnings:");
        entry.warnings.forEach((warning) => {
          console.log(`   \u2022 ${warning} (warning)`);
        });
      }
    });
    const contextLabel = options.context === "test" ? "Test summary" : "Validation summary";
    console.log(`${contextLabel}: ${summary.passed}/${summary.total} files valid${options.strict ? " (strict)" : ""}`);
  }
  if (summary.failed > 0) {
    process.exitCode = 1;
  }
}
function isEffectivelyValid(result, strict) {
  return result.ok && (!strict || result.warnings.length === 0);
}
function readJsonFile(relativePath) {
  const absolutePath = path__namespace.resolve(relativePath);
  if (!fs__namespace.existsSync(absolutePath)) {
    throw new Error(`File not found: ${absolutePath}`);
  }
  const content = fs__namespace.readFileSync(absolutePath, "utf-8");
  try {
    return JSON.parse(content);
  } catch {
    throw new Error(`Unable to parse JSON in ${absolutePath}`);
  }
}
function resolveOutputPath(args) {
  const index = args.findIndex((arg) => arg === "-o" || arg === "--output");
  if (index === -1) return void 0;
  const target = args[index + 1];
  if (!target) {
    throw new Error("Output flag provided without a path");
  }
  return target;
}
function writeOutput(data, outputPath) {
  const serialized = JSON.stringify(data, null, 2);
  if (!outputPath) {
    console.log(serialized);
    return;
  }
  const absolutePath = path__namespace.resolve(outputPath);
  fs__namespace.writeFileSync(absolutePath, serialized, "utf-8");
}
function buildConformanceReport(result) {
  const recipe = result.normalizedRecipe;
  const level = typeof recipe?.level === "string" ? recipe.level : null;
  const stacks = normalizeStacksForReport(recipe?.stacks);
  const schemaErrors = sortSchemaErrors(result.schemaErrors).map((error) => ({
    path: error.path,
    keyword: error.keyword ?? null,
    message: error.message
  }));
  const conformanceIssues = sortConformanceIssues(result.conformanceIssues).map((issue) => ({
    code: issue.code,
    path: issue.path,
    severity: issue.severity === "warning" ? "warn" : "error",
    message: issue.message
  }));
  return {
    ok: result.ok,
    level,
    stacks,
    warnings: result.warnings,
    schemaErrors,
    conformanceIssues
  };
}
function normalizeStacksForReport(stacks) {
  if (!stacks || typeof stacks !== "object" || Array.isArray(stacks)) return {};
  const entries = Object.entries(stacks).filter(([, value]) => typeof value === "number");
  entries.sort(([a], [b]) => a.localeCompare(b));
  return Object.fromEntries(entries);
}
function sortSchemaErrors(errors) {
  return [...errors].sort((left, right) => {
    const pathCompare = left.path.localeCompare(right.path);
    if (pathCompare !== 0) return pathCompare;
    const leftKeyword = left.keyword ?? "";
    const rightKeyword = right.keyword ?? "";
    return leftKeyword.localeCompare(rightKeyword);
  });
}
function sortConformanceIssues(issues) {
  return [...issues].sort((left, right) => {
    const pathCompare = left.path.localeCompare(right.path);
    if (pathCompare !== 0) return pathCompare;
    return left.code.localeCompare(right.code);
  });
}
if (__require.main === module) {
  runCli(process.argv.slice(2)).catch((error) => {
    console.error(`\u274C ${error?.message ?? error}`);
    process.exit(1);
  });
}

exports.runCli = runCli;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map