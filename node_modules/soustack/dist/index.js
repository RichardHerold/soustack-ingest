'use strict';

var Ajv2020 = require('ajv/dist/2020');
var addFormats = require('ajv-formats');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var Ajv2020__default = /*#__PURE__*/_interopDefault(Ajv2020);
var addFormats__default = /*#__PURE__*/_interopDefault(addFormats);

// src/parsers/duration.ts
var ISO_DURATION_REGEX = /^P(?:(\d+(?:\.\d+)?)D)?(?:T(?:(\d+(?:\.\d+)?)H)?(?:(\d+(?:\.\d+)?)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
var HUMAN_OVERNIGHT = 8 * 60;
function isFiniteNumber(value) {
  return typeof value === "number" && Number.isFinite(value);
}
function parseDuration(iso) {
  if (typeof iso === "number" && Number.isFinite(iso)) {
    return iso;
  }
  if (!iso || typeof iso !== "string") return null;
  const trimmed = iso.trim();
  if (!trimmed) return null;
  const match = trimmed.match(ISO_DURATION_REGEX);
  if (!match) return null;
  const [, daysRaw, hoursRaw, minutesRaw, secondsRaw] = match;
  if (!daysRaw && !hoursRaw && !minutesRaw && !secondsRaw) {
    return null;
  }
  let total = 0;
  if (daysRaw) total += parseFloat(daysRaw) * 24 * 60;
  if (hoursRaw) total += parseFloat(hoursRaw) * 60;
  if (minutesRaw) total += parseFloat(minutesRaw);
  if (secondsRaw) total += Math.ceil(parseFloat(secondsRaw) / 60);
  return Math.round(total);
}
function formatDuration(minutes) {
  if (!isFiniteNumber(minutes) || minutes <= 0) {
    return "PT0M";
  }
  const rounded = Math.round(minutes);
  const days = Math.floor(rounded / (24 * 60));
  const afterDays = rounded % (24 * 60);
  const hours = Math.floor(afterDays / 60);
  const mins = afterDays % 60;
  let result = "P";
  if (days > 0) {
    result += `${days}D`;
  }
  if (hours > 0 || mins > 0) {
    result += "T";
    if (hours > 0) {
      result += `${hours}H`;
    }
    if (mins > 0) {
      result += `${mins}M`;
    }
  }
  if (result === "P") {
    return "PT0M";
  }
  return result;
}
function parseHumanDuration(text) {
  if (!text || typeof text !== "string") return null;
  const normalized = text.toLowerCase().trim();
  if (!normalized) return null;
  if (normalized === "overnight") {
    return HUMAN_OVERNIGHT;
  }
  let total = 0;
  const hourRegex = /(\d+(?:\.\d+)?)\s*(?:hours?|hrs?|hr|h)\b/g;
  let hourMatch;
  while ((hourMatch = hourRegex.exec(normalized)) !== null) {
    total += parseFloat(hourMatch[1]) * 60;
  }
  const minuteRegex = /(\d+(?:\.\d+)?)\s*(?:minutes?|mins?|min|m)\b/g;
  let minuteMatch;
  while ((minuteMatch = minuteRegex.exec(normalized)) !== null) {
    total += parseFloat(minuteMatch[1]);
  }
  if (total <= 0) {
    return null;
  }
  return Math.round(total);
}
function smartParseDuration(input) {
  const iso = parseDuration(input);
  if (iso !== null) {
    return iso;
  }
  return parseHumanDuration(input);
}

// src/parser.ts
function scaleRecipe(recipe, options = {}) {
  const multiplier = resolveMultiplier(recipe, options);
  const scaled = deepClone(recipe);
  applyYieldScaling(scaled, options, multiplier);
  const baseAmounts = collectBaseIngredientAmounts(scaled.ingredients || []);
  const scaledAmounts = /* @__PURE__ */ new Map();
  const orderedIngredients = [];
  collectIngredients(scaled.ingredients || [], orderedIngredients);
  orderedIngredients.filter((ing) => {
    var _a;
    return (((_a = ing.scaling) == null ? void 0 : _a.type) || "linear") !== "bakers_percentage";
  }).forEach((ing) => {
    const key = getIngredientKey(ing);
    scaledAmounts.set(key, calculateIndependentIngredient(ing, multiplier));
  });
  orderedIngredients.filter((ing) => {
    var _a;
    return ((_a = ing.scaling) == null ? void 0 : _a.type) === "bakers_percentage";
  }).forEach((ing) => {
    var _a, _b;
    const key = getIngredientKey(ing);
    const scaling = ing.scaling;
    if (!(scaling == null ? void 0 : scaling.referenceId)) {
      throw new Error(`Baker's percentage ingredient "${key}" is missing a referenceId`);
    }
    const referenceAmount = scaledAmounts.get(scaling.referenceId);
    if (referenceAmount === void 0) {
      throw new Error(`Reference ingredient "${scaling.referenceId}" not found for baker's percentage item "${key}"`);
    }
    const baseAmount = ((_a = ing.quantity) == null ? void 0 : _a.amount) || 0;
    const referenceBase = baseAmounts.get(scaling.referenceId);
    const factor = (_b = scaling.factor) != null ? _b : referenceBase ? baseAmount / referenceBase : void 0;
    if (factor === void 0) {
      throw new Error(`Unable to determine factor for baker's percentage ingredient "${key}"`);
    }
    scaledAmounts.set(key, referenceAmount * factor);
  });
  orderedIngredients.forEach((ing) => {
    const key = getIngredientKey(ing);
    const amount = scaledAmounts.get(key);
    if (amount === void 0) return;
    if (!ing.quantity) {
      ing.quantity = { amount, unit: null };
    } else {
      ing.quantity.amount = amount;
    }
  });
  scaleInstructionItems(scaled.instructions || [], multiplier);
  return scaled;
}
function resolveMultiplier(recipe, options) {
  var _a, _b;
  if (options.multiplier && options.multiplier > 0) {
    return options.multiplier;
  }
  if ((_a = options.targetYield) == null ? void 0 : _a.amount) {
    const base = ((_b = recipe.yield) == null ? void 0 : _b.amount) || 1;
    return options.targetYield.amount / base;
  }
  return 1;
}
function applyYieldScaling(recipe, options, multiplier) {
  var _a, _b, _c, _d, _e, _f, _g;
  const baseAmount = (_b = (_a = recipe.yield) == null ? void 0 : _a.amount) != null ? _b : 1;
  const targetAmount = (_d = (_c = options.targetYield) == null ? void 0 : _c.amount) != null ? _d : baseAmount * multiplier;
  const unit = (_g = (_e = options.targetYield) == null ? void 0 : _e.unit) != null ? _g : (_f = recipe.yield) == null ? void 0 : _f.unit;
  if (!recipe.yield && !options.targetYield) return;
  recipe.yield = {
    amount: targetAmount,
    unit: unit != null ? unit : ""
  };
}
function getIngredientKey(ing) {
  return ing.id || ing.item;
}
function calculateIndependentIngredient(ing, multiplier) {
  var _a, _b, _c, _d, _e, _f;
  const baseAmount = ((_a = ing.quantity) == null ? void 0 : _a.amount) || 0;
  const type = ((_b = ing.scaling) == null ? void 0 : _b.type) || "linear";
  switch (type) {
    case "fixed":
      return baseAmount;
    case "discrete": {
      const scaled = baseAmount * multiplier;
      const step = (_d = (_c = ing.scaling) == null ? void 0 : _c.roundTo) != null ? _d : 1;
      const rounded = Math.round(scaled / step) * step;
      return Math.round(rounded);
    }
    case "proportional": {
      const factor = (_f = (_e = ing.scaling) == null ? void 0 : _e.factor) != null ? _f : 1;
      return baseAmount * multiplier * factor;
    }
    default:
      return baseAmount * multiplier;
  }
}
function collectIngredients(items, bucket) {
  items.forEach((item) => {
    if (typeof item === "string") return;
    if ("subsection" in item) {
      collectIngredients(item.items, bucket);
    } else {
      bucket.push(item);
    }
  });
}
function collectBaseIngredientAmounts(items, map = /* @__PURE__ */ new Map()) {
  items.forEach((item) => {
    var _a, _b;
    if (typeof item === "string") return;
    if ("subsection" in item) {
      collectBaseIngredientAmounts(item.items, map);
    } else {
      map.set(getIngredientKey(item), (_b = (_a = item.quantity) == null ? void 0 : _a.amount) != null ? _b : 0);
    }
  });
  return map;
}
function scaleInstructionItems(items, multiplier) {
  items.forEach((item) => {
    if (typeof item === "string") return;
    if ("subsection" in item) {
      scaleInstructionItems(item.items, multiplier);
      return;
    }
    const timing = item.timing;
    if (!timing) return;
    const baseDuration = toDurationMinutes(timing.duration);
    const scalingType = timing.scaling || "fixed";
    let newDuration = baseDuration;
    if (scalingType === "linear") {
      newDuration = baseDuration * multiplier;
    } else if (scalingType === "sqrt") {
      newDuration = baseDuration * Math.sqrt(multiplier);
    }
    timing.duration = Math.ceil(newDuration);
  });
}
function deepClone(value) {
  return JSON.parse(JSON.stringify(value));
}
function toDurationMinutes(duration) {
  if (typeof duration === "number" && Number.isFinite(duration)) {
    return duration;
  }
  if (typeof duration === "string" && duration.trim().startsWith("P")) {
    const parsed = parseDuration(duration.trim());
    if (parsed !== null) {
      return parsed;
    }
  }
  return 0;
}

// src/normalize.ts
function normalizeRecipe(input) {
  if (!input || typeof input !== "object") {
    throw new Error("Recipe input must be an object");
  }
  const recipe = JSON.parse(JSON.stringify(input));
  const warnings = [];
  const legacyField = ["mod", "ules"].join("");
  if (legacyField in recipe) {
    throw new Error("The legacy field is no longer supported. Use `stacks` instead.");
  }
  normalizeStacks(recipe, warnings);
  if (!recipe.stacks) {
    recipe.stacks = {};
  }
  if (recipe && typeof recipe === "object" && "version" in recipe && !recipe.recipeVersion && typeof recipe.version === "string") {
    recipe.recipeVersion = recipe.version;
    warnings.push("'version' is deprecated; mapped to 'recipeVersion'.");
  }
  normalizeTime(recipe);
  return {
    recipe,
    warnings
  };
}
function normalizeStacks(recipe, warnings) {
  let stacks = {};
  if (recipe.stacks && typeof recipe.stacks === "object" && !Array.isArray(recipe.stacks)) {
    for (const [key, value] of Object.entries(recipe.stacks)) {
      if (typeof value === "number" && Number.isInteger(value) && value >= 1) {
        stacks[key] = value;
      } else {
        warnings.push(`Invalid stack version for '${key}': expected positive integer, got ${value}`);
      }
    }
  }
  if (Array.isArray(recipe.stacks)) {
    const stackIdentifiers = recipe.stacks.filter((s) => typeof s === "string");
    for (const identifier of stackIdentifiers) {
      const parsed = parseStackIdentifier(identifier);
      if (parsed) {
        const { name, version } = parsed;
        if (!stacks[name] || stacks[name] < version) {
          stacks[name] = version;
        }
      } else {
        warnings.push(`Invalid stack identifier '${identifier}': expected format 'name@version' (e.g., 'scaling@1')`);
      }
    }
  }
  recipe.stacks = stacks;
}
function parseStackIdentifier(identifier) {
  if (typeof identifier !== "string" || !identifier.trim()) {
    return null;
  }
  const match = identifier.trim().match(/^([a-z0-9_-]+)@(\d+)$/i);
  if (!match) {
    return null;
  }
  const [, name, versionStr] = match;
  const version = parseInt(versionStr, 10);
  if (isNaN(version) || version < 1) {
    return null;
  }
  return { name, version };
}
function normalizeTime(recipe) {
  const time = recipe == null ? void 0 : recipe.time;
  if (!time || typeof time !== "object" || Array.isArray(time)) return;
  const structuredKeys = [
    "prep",
    "active",
    "passive",
    "total"
  ];
  structuredKeys.forEach((key) => {
    const value = time[key];
    if (typeof value === "number") return;
    const parsed = parseDuration(value);
    if (parsed !== null) {
      time[key] = parsed;
    }
  });
}

// src/conformance/index.ts
function validateConformance(recipe) {
  const issues = [];
  issues.push(...checkDAGValidity(recipe));
  if (hasSchedulableProfile(recipe)) {
    issues.push(...checkTimingSchedulability(recipe));
  }
  issues.push(...checkScalingSanity(recipe));
  const ok = issues.filter((i) => i.severity === "error").length === 0;
  return { ok, issues };
}
function hasSchedulableProfile(recipe) {
  const schema = recipe.$schema;
  if (typeof schema === "string") {
    return schema.includes("schedulable") || schema === "http://soustack.org/schema/v0.3.0/profiles/schedulable";
  }
  return false;
}
function checkDAGValidity(recipe) {
  const issues = [];
  const instructions = recipe.instructions;
  if (!Array.isArray(instructions)) {
    return issues;
  }
  const instructionIds = /* @__PURE__ */ new Set();
  const dependencyRefs = [];
  const collect = (items, basePath) => {
    items.forEach((item, index) => {
      const currentPath = `${basePath}/${index}`;
      if (isInstructionSubsection(item)) {
        if (Array.isArray(item.items)) {
          collect(item.items, `${currentPath}/items`);
        }
        return;
      }
      if (isInstruction(item)) {
        const id = typeof item.id === "string" ? item.id : void 0;
        if (id) {
          instructionIds.add(id);
        }
        if (Array.isArray(item.dependsOn)) {
          item.dependsOn.forEach((depId, depIndex) => {
            if (typeof depId === "string") {
              dependencyRefs.push({
                fromId: id,
                toId: depId,
                path: `${currentPath}/dependsOn/${depIndex}`
              });
            }
          });
        }
      }
    });
  };
  collect(instructions, "/instructions");
  dependencyRefs.forEach((ref) => {
    if (!instructionIds.has(ref.toId)) {
      issues.push({
        code: "DAG_MISSING_NODE",
        path: ref.path,
        message: `Instruction dependency references missing step id '${ref.toId}'.`,
        severity: "error"
      });
    }
  });
  const adjacency = /* @__PURE__ */ new Map();
  dependencyRefs.forEach((ref) => {
    var _a;
    if (ref.fromId && instructionIds.has(ref.fromId) && instructionIds.has(ref.toId)) {
      const list = (_a = adjacency.get(ref.fromId)) != null ? _a : [];
      list.push({ toId: ref.toId, path: ref.path });
      adjacency.set(ref.fromId, list);
    }
  });
  const visiting = /* @__PURE__ */ new Set();
  const visited = /* @__PURE__ */ new Set();
  const detectCycles = (nodeId) => {
    var _a;
    if (visiting.has(nodeId)) {
      return;
    }
    if (visited.has(nodeId)) {
      return;
    }
    visiting.add(nodeId);
    const neighbors = (_a = adjacency.get(nodeId)) != null ? _a : [];
    neighbors.forEach((edge) => {
      if (visiting.has(edge.toId)) {
        issues.push({
          code: "DAG_CYCLE",
          path: edge.path,
          message: `Circular dependency detected involving step id '${edge.toId}'.`,
          severity: "error"
        });
        return;
      }
      detectCycles(edge.toId);
    });
    visiting.delete(nodeId);
    visited.add(nodeId);
  };
  instructionIds.forEach((id) => detectCycles(id));
  return issues;
}
function checkTimingSchedulability(recipe) {
  const issues = [];
  const instructions = recipe.instructions;
  if (!Array.isArray(instructions)) {
    return issues;
  }
  const checkInstruction = (item, path) => {
    if (isInstructionSubsection(item)) {
      if (Array.isArray(item.items)) {
        item.items.forEach((subItem, index) => {
          checkInstruction(subItem, `${path}/items/${index}`);
        });
      }
      return;
    }
    if (isInstruction(item)) {
      if (!item.id) {
        issues.push({
          code: "SCHEDULABLE_MISSING_ID",
          path,
          message: "Schedulable profile requires all instructions to have an id.",
          severity: "error"
        });
      }
      if (!item.timing) {
        issues.push({
          code: "SCHEDULABLE_MISSING_TIMING",
          path,
          message: "Schedulable profile requires all instructions to have timing information.",
          severity: "error"
        });
      } else if (!item.timing.duration) {
        issues.push({
          code: "SCHEDULABLE_MISSING_DURATION",
          path: `${path}/timing`,
          message: "Schedulable profile requires timing.duration for all instructions.",
          severity: "error"
        });
      }
    }
  };
  instructions.forEach((item, index) => {
    checkInstruction(item, `/instructions/${index}`);
  });
  return issues;
}
function checkScalingSanity(recipe) {
  const issues = [];
  const ingredients = recipe.ingredients;
  if (!Array.isArray(ingredients)) {
    return issues;
  }
  const ingredientIds = /* @__PURE__ */ new Set();
  const collectIngredientIds = (items, basePath) => {
    items.forEach((item, index) => {
      if (isIngredientSubsection(item)) {
        if (Array.isArray(item.items)) {
          collectIngredientIds(item.items);
        }
        return;
      }
      if (isIngredient(item)) {
        if (typeof item.id === "string") {
          ingredientIds.add(item.id);
        }
      }
    });
  };
  collectIngredientIds(ingredients);
  const checkIngredient = (item, path) => {
    if (isIngredientSubsection(item)) {
      if (Array.isArray(item.items)) {
        item.items.forEach((subItem, index) => {
          checkIngredient(subItem, `${path}/items/${index}`);
        });
      }
      return;
    }
    if (isIngredient(item)) {
      const scaling = item.scaling;
      if (scaling && typeof scaling === "object" && "type" in scaling && scaling.type === "bakers_percentage") {
        const bakersScaling = scaling;
        if (bakersScaling.referenceId) {
          if (!ingredientIds.has(bakersScaling.referenceId)) {
            issues.push({
              code: "SCALING_INVALID_REFERENCE",
              path: `${path}/scaling/referenceId`,
              message: `Baker's percentage references missing ingredient id '${bakersScaling.referenceId}'.`,
              severity: "error"
            });
          }
        } else {
          issues.push({
            code: "SCALING_MISSING_REFERENCE",
            path: `${path}/scaling`,
            message: "Baker's percentage scaling requires a referenceId.",
            severity: "error"
          });
        }
      }
    }
  };
  ingredients.forEach((item, index) => {
    checkIngredient(item, `/ingredients/${index}`);
  });
  return issues;
}
function isInstruction(item) {
  return item && typeof item === "object" && !Array.isArray(item) && "text" in item;
}
function isInstructionSubsection(item) {
  return item && typeof item === "object" && !Array.isArray(item) && "items" in item && "subsection" in item;
}
function isIngredient(item) {
  return item && typeof item === "object" && !Array.isArray(item) && "item" in item;
}
function isIngredientSubsection(item) {
  return item && typeof item === "object" && !Array.isArray(item) && "items" in item && "subsection" in item;
}

// src/soustack.schema.json
var soustack_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0",
  title: "Soustack Recipe Schema v0.3.0",
  description: "A portable, scalable, interoperable recipe format.",
  type: "object",
  required: ["name", "ingredients", "instructions"],
  additionalProperties: false,
  patternProperties: {
    "^x-": {}
  },
  properties: {
    $schema: {
      type: "string",
      format: "uri",
      description: "Optional schema hint for tooling compatibility"
    },
    id: {
      type: "string",
      description: "Unique identifier (slug or UUID)"
    },
    name: {
      type: "string",
      description: "The title of the recipe"
    },
    title: {
      type: "string",
      description: "Optional display title; alias for name"
    },
    version: {
      type: "string",
      pattern: "^\\d+\\.\\d+\\.\\d+$",
      description: "DEPRECATED: use recipeVersion for authoring revisions"
    },
    recipeVersion: {
      type: "string",
      pattern: "^\\d+\\.\\d+\\.\\d+$",
      description: "Recipe content revision (semantic versioning, e.g., 1.0.0)"
    },
    description: {
      type: "string"
    },
    category: {
      type: "string",
      examples: ["Main Course", "Dessert"]
    },
    tags: {
      type: "array",
      items: { type: "string" }
    },
    image: {
      description: "Recipe-level hero image(s)",
      anyOf: [
        {
          type: "string",
          format: "uri"
        },
        {
          type: "array",
          minItems: 1,
          items: {
            type: "string",
            format: "uri"
          }
        }
      ]
    },
    dateAdded: {
      type: "string",
      format: "date-time"
    },
    metadata: {
      type: "object",
      additionalProperties: true,
      description: "Free-form vendor metadata"
    },
    source: {
      type: "object",
      properties: {
        author: { type: "string" },
        url: { type: "string", format: "uri" },
        name: { type: "string" },
        adapted: { type: "boolean" }
      }
    },
    yield: {
      $ref: "#/definitions/yield"
    },
    time: {
      $ref: "#/definitions/time"
    },
    equipment: {
      type: "array",
      items: { $ref: "#/definitions/equipment" }
    },
    ingredients: {
      type: "array",
      items: {
        anyOf: [
          { type: "string" },
          { $ref: "#/definitions/ingredient" },
          { $ref: "#/definitions/ingredientSubsection" }
        ]
      }
    },
    instructions: {
      type: "array",
      items: {
        anyOf: [
          { type: "string" },
          { $ref: "#/definitions/instruction" },
          { $ref: "#/definitions/instructionSubsection" }
        ]
      }
    },
    storage: {
      $ref: "#/definitions/storage"
    },
    substitutions: {
      type: "array",
      items: { $ref: "#/definitions/substitution" }
    }
  },
  definitions: {
    yield: {
      type: "object",
      required: ["amount", "unit"],
      properties: {
        amount: { type: "number" },
        unit: { type: "string" },
        servings: { type: "number" },
        description: { type: "string" }
      }
    },
    time: {
      type: "object",
      properties: {
        prep: { type: "number" },
        active: { type: "number" },
        passive: { type: "number" },
        total: { type: "number" },
        prepTime: { type: "string", format: "duration" },
        cookTime: { type: "string", format: "duration" }
      },
      minProperties: 1
    },
    quantity: {
      type: "object",
      required: ["amount"],
      properties: {
        amount: { type: "number" },
        unit: {
          type: ["string", "null"],
          description: "Display-friendly unit text; implementations may normalize or canonicalize units separately."
        }
      }
    },
    scaling: {
      type: "object",
      required: ["type"],
      properties: {
        type: {
          type: "string",
          enum: ["linear", "discrete", "proportional", "fixed", "bakers_percentage"]
        },
        factor: { type: "number" },
        referenceId: { type: "string" },
        roundTo: { type: "number" },
        min: { type: "number" },
        max: { type: "number" }
      },
      if: {
        properties: { type: { const: "bakers_percentage" } }
      },
      then: {
        required: ["referenceId"]
      }
    },
    ingredient: {
      type: "object",
      required: ["item"],
      properties: {
        id: { type: "string" },
        item: { type: "string" },
        quantity: { $ref: "#/definitions/quantity" },
        name: { type: "string" },
        aisle: { type: "string" },
        prep: { type: "string" },
        prepAction: { type: "string" },
        prepActions: {
          type: "array",
          items: { type: "string" },
          description: "Structured prep verbs (e.g., peel, dice) for mise en place workflows."
        },
        prepTime: { type: "number" },
        form: {
          type: "string",
          description: "State of the ingredient as used (packed, sifted, melted, room_temperature, etc.)."
        },
        destination: { type: "string" },
        scaling: { $ref: "#/definitions/scaling" },
        critical: { type: "boolean" },
        optional: { type: "boolean" },
        notes: { type: "string" }
      }
    },
    ingredientSubsection: {
      type: "object",
      required: ["subsection", "items"],
      properties: {
        subsection: { type: "string" },
        items: {
          type: "array",
          items: { $ref: "#/definitions/ingredient" }
        }
      }
    },
    equipment: {
      type: "object",
      required: ["name"],
      properties: {
        id: { type: "string" },
        name: { type: "string" },
        required: { type: "boolean" },
        label: { type: "string" },
        capacity: { $ref: "#/definitions/quantity" },
        scalingLimit: { type: "number" },
        alternatives: {
          type: "array",
          items: { type: "string" }
        }
      }
    },
    instruction: {
      type: "object",
      required: ["text"],
      properties: {
        id: { type: "string" },
        text: { type: "string" },
        image: {
          type: "string",
          format: "uri",
          description: "Optional image that illustrates this instruction"
        },
        destination: { type: "string" },
        dependsOn: {
          type: "array",
          items: { type: "string" }
        },
        inputs: {
          type: "array",
          items: { type: "string" }
        },
        timing: {
          type: "object",
          required: ["duration", "type"],
          properties: {
            duration: {
              anyOf: [
                { type: "number" },
                { type: "string", pattern: "^P" }
              ],
              description: "Minutes as a number or ISO8601 duration string"
            },
            type: { type: "string", enum: ["active", "passive"] },
            scaling: { type: "string", enum: ["linear", "fixed", "sqrt"] }
          }
        }
      }
    },
    instructionSubsection: {
      type: "object",
      required: ["subsection", "items"],
      properties: {
        subsection: { type: "string" },
        items: {
          type: "array",
          items: {
            anyOf: [
              { type: "string" },
              { $ref: "#/definitions/instruction" }
            ]
          }
        }
      }
    },
    storage: {
      type: "object",
      properties: {
        roomTemp: { $ref: "#/definitions/storageMethod" },
        refrigerated: { $ref: "#/definitions/storageMethod" },
        frozen: {
          allOf: [
            { $ref: "#/definitions/storageMethod" },
            {
              type: "object",
              properties: { thawing: { type: "string" } }
            }
          ]
        },
        reheating: { type: "string" },
        makeAhead: {
          type: "array",
          items: {
            allOf: [
              { $ref: "#/definitions/storageMethod" },
              {
                type: "object",
                required: ["component", "storage"],
                properties: {
                  component: { type: "string" },
                  storage: { type: "string", enum: ["roomTemp", "refrigerated", "frozen"] }
                }
              }
            ]
          }
        }
      }
    },
    storageMethod: {
      type: "object",
      required: ["duration"],
      properties: {
        duration: { type: "string", pattern: "^P" },
        method: { type: "string" },
        notes: { type: "string" }
      }
    },
    substitution: {
      type: "object",
      required: ["ingredient"],
      properties: {
        ingredient: { type: "string" },
        critical: { type: "boolean" },
        notes: { type: "string" },
        alternatives: {
          type: "array",
          items: {
            type: "object",
            required: ["name", "ratio"],
            properties: {
              name: { type: "string" },
              ratio: { type: "string" },
              notes: { type: "string" },
              impact: { type: "string" },
              dietary: {
                type: "array",
                items: { type: "string" }
              }
            }
          }
        }
      }
    }
  }
};

// src/schemas/recipe/base.schema.json
var base_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/recipe/base.schema.json",
  title: "Soustack Recipe Base Schema",
  description: "Base document shape for Soustack recipe documents. Profiles and stacks build on this baseline.",
  type: "object",
  additionalProperties: true,
  properties: {
    "@type": {
      const: "Recipe",
      description: "Document marker for Soustack recipes"
    },
    profile: {
      type: "string",
      description: "Profile identifier applied to this recipe"
    },
    stacks: {
      type: "object",
      description: "Stack declarations as a map: Record<stackName, versionNumber>",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    name: {
      type: "string",
      description: "Human-readable recipe name"
    },
    ingredients: {
      type: "array",
      description: "Ingredients payload; content is validated by profiles/stacks"
    },
    instructions: {
      type: "array",
      description: "Instruction payload; content is validated by profiles/stacks"
    }
  },
  required: ["@type"]
};

// src/schemas/recipe/profiles/minimal.schema.json
var minimal_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/recipe/profiles/minimal.schema.json",
  title: "Soustack Recipe Minimal Profile",
  description: "Minimal profile that ensures the basic Recipe structure is present while allowing stacks to extend it.",
  allOf: [
    {
      $ref: "http://soustack.org/schema/recipe/base.schema.json"
    },
    {
      type: "object",
      properties: {
        profile: {
          const: "minimal"
        },
        stacks: {
          type: "object",
          additionalProperties: {
            type: "integer",
            minimum: 1
          },
          properties: {
            attribution: { type: "integer", minimum: 1 },
            taxonomy: { type: "integer", minimum: 1 },
            media: { type: "integer", minimum: 1 },
            nutrition: { type: "integer", minimum: 1 },
            times: { type: "integer", minimum: 1 }
          }
        },
        name: {
          type: "string",
          minLength: 1
        },
        ingredients: {
          type: "array",
          minItems: 1
        },
        instructions: {
          type: "array",
          minItems: 1
        }
      },
      required: [
        "profile",
        "name",
        "ingredients",
        "instructions"
      ],
      additionalProperties: true
    }
  ]
};

// src/schemas/recipe/profiles/core.schema.json
var core_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/recipe/profiles/core.schema.json",
  title: "Soustack Recipe Core Profile",
  description: "Core profile that builds on the minimal profile and is intended to be combined with recipe stacks.",
  allOf: [
    { $ref: "http://soustack.org/schema/recipe/base.schema.json" },
    {
      type: "object",
      properties: {
        profile: { const: "core" },
        stacks: {
          type: "object",
          additionalProperties: {
            type: "integer",
            minimum: 1
          }
        },
        name: { type: "string", minLength: 1 },
        ingredients: { type: "array", minItems: 1 },
        instructions: { type: "array", minItems: 1 }
      },
      required: ["profile", "name", "ingredients", "instructions"],
      additionalProperties: true
    }
  ]
};

// spec/profiles/base.schema.json
var base_schema_default2 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/base",
  title: "Soustack Base Profile Schema",
  description: "Wrapper schema that exposes the unmodified Soustack base schema.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" }
  ]
};

// spec/profiles/cookable.schema.json
var cookable_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/cookable",
  title: "Soustack Cookable Profile Schema",
  description: "Extends the base schema to require structured yield + time metadata and non-empty ingredient/instruction lists.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" },
    {
      required: ["yield", "time", "ingredients", "instructions"],
      properties: {
        yield: { $ref: "http://soustack.org/schema/v0.3.0#/definitions/yield" },
        time: { $ref: "http://soustack.org/schema/v0.3.0#/definitions/time" },
        ingredients: { type: "array", minItems: 1 },
        instructions: { type: "array", minItems: 1 }
      }
    }
  ]
};

// spec/profiles/illustrated.schema.json
var illustrated_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/illustrated",
  title: "Soustack Illustrated Profile Schema",
  description: "Extends the base schema to guarantee at least one illustrative image.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" },
    {
      anyOf: [
        { required: ["image"] },
        {
          properties: {
            instructions: {
              type: "array",
              contains: {
                anyOf: [
                  { $ref: "#/definitions/imageInstruction" },
                  { $ref: "#/definitions/instructionSubsectionWithImage" }
                ]
              }
            }
          }
        }
      ]
    }
  ],
  definitions: {
    imageInstruction: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/instruction" },
        { required: ["image"] }
      ]
    },
    instructionSubsectionWithImage: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/instructionSubsection" },
        {
          properties: {
            items: {
              type: "array",
              contains: { $ref: "#/definitions/imageInstruction" }
            }
          }
        }
      ]
    }
  }
};

// spec/profiles/quantified.schema.json
var quantified_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/quantified",
  title: "Soustack Quantified Profile Schema",
  description: "Extends the base schema to require quantified ingredient entries.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" },
    {
      properties: {
        ingredients: {
          type: "array",
          items: {
            anyOf: [
              { $ref: "#/definitions/quantifiedIngredient" },
              { $ref: "#/definitions/quantifiedIngredientSubsection" }
            ]
          }
        }
      }
    }
  ],
  definitions: {
    quantifiedIngredient: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/ingredient" },
        { required: ["item", "quantity"] }
      ]
    },
    quantifiedIngredientSubsection: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/ingredientSubsection" },
        {
          properties: {
            items: {
              type: "array",
              items: { $ref: "#/definitions/quantifiedIngredient" }
            }
          }
        }
      ]
    }
  }
};

// spec/profiles/scalable.schema.json
var scalable_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/scalable",
  title: "Soustack Scalable Profile Schema",
  description: "Extends the base schema to guarantee quantified ingredients plus a structured yield for deterministic scaling.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" },
    {
      required: ["yield", "ingredients"],
      properties: {
        yield: {
          allOf: [
            { $ref: "http://soustack.org/schema/v0.3.0#/definitions/yield" },
            { properties: { amount: { type: "number", exclusiveMinimum: 0 } } }
          ]
        },
        ingredients: {
          type: "array",
          minItems: 1,
          items: {
            anyOf: [
              { $ref: "#/definitions/scalableIngredient" },
              { $ref: "#/definitions/scalableIngredientSubsection" }
            ]
          }
        }
      }
    }
  ],
  definitions: {
    scalableIngredient: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/ingredient" },
        { required: ["item", "quantity"] },
        {
          properties: {
            quantity: {
              allOf: [
                { $ref: "http://soustack.org/schema/v0.3.0#/definitions/quantity" },
                { properties: { amount: { type: "number", exclusiveMinimum: 0 } } }
              ]
            }
          }
        },
        {
          if: {
            properties: {
              scaling: {
                type: "object",
                properties: { type: { const: "bakers_percentage" } },
                required: ["type"]
              }
            },
            required: ["scaling"]
          },
          then: { required: ["id"] }
        }
      ]
    },
    scalableIngredientSubsection: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/ingredientSubsection" },
        {
          properties: {
            items: {
              type: "array",
              minItems: 1,
              items: { $ref: "#/definitions/scalableIngredient" }
            }
          }
        }
      ]
    }
  }
};

// spec/profiles/schedulable.schema.json
var schedulable_schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "http://soustack.org/schema/v0.3.0/profiles/schedulable",
  title: "Soustack Schedulable Profile Schema",
  description: "Extends the base schema to ensure every instruction is fully scheduled.",
  allOf: [
    { $ref: "http://soustack.org/schema/v0.3.0" },
    {
      properties: {
        instructions: {
          type: "array",
          items: {
            anyOf: [
              { $ref: "#/definitions/schedulableInstruction" },
              { $ref: "#/definitions/schedulableInstructionSubsection" }
            ]
          }
        }
      }
    }
  ],
  definitions: {
    schedulableInstruction: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/instruction" },
        { required: ["id", "timing"] }
      ]
    },
    schedulableInstructionSubsection: {
      allOf: [
        { $ref: "http://soustack.org/schema/v0.3.0#/definitions/instructionSubsection" },
        {
          properties: {
            items: {
              type: "array",
              items: { $ref: "#/definitions/schedulableInstruction" }
            }
          }
        }
      ]
    }
  }
};

// src/schemas/recipe/stacks/attribution/1.schema.json
var schema_default = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/attribution/1.schema.json",
  title: "Soustack Recipe Stack: attribution v1",
  description: "Schema for the attribution stack. Ensures namespace data is present when the stack is enabled and vice versa.",
  type: "object",
  properties: {
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    attribution: {
      type: "object",
      properties: {
        url: { type: "string" },
        author: { type: "string" },
        datePublished: { type: "string" }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              attribution: { const: 1 }
            },
            required: ["attribution"]
          }
        }
      },
      then: {
        required: ["attribution"]
      }
    },
    {
      if: {
        required: ["attribution"]
      },
      then: {
        required: ["stacks"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              attribution: { const: 1 }
            },
            required: ["attribution"]
          }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/schemas/recipe/stacks/media/1.schema.json
var schema_default2 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/media/1.schema.json",
  title: "Soustack Recipe Stack: media v1",
  description: "Schema for the media stack. Guards media blocks based on stack activation and ensures declarations accompany payloads.",
  type: "object",
  properties: {
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    media: {
      type: "object",
      properties: {
        images: { type: "array", items: { type: "string" } },
        videos: { type: "array", items: { type: "string" } }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              media: { const: 1 }
            },
            required: ["media"]
          }
        }
      },
      then: {
        required: ["media"]
      }
    },
    {
      if: {
        required: ["media"]
      },
      then: {
        required: ["stacks"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              media: { const: 1 }
            },
            required: ["media"]
          }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/schemas/recipe/stacks/nutrition/1.schema.json
var schema_default3 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/nutrition/1.schema.json",
  title: "Soustack Recipe Stack: nutrition v1",
  description: "Schema for the nutrition stack. Keeps nutrition data aligned with stack declarations and vice versa.",
  type: "object",
  properties: {
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    nutrition: {
      type: "object",
      properties: {
        calories: { type: "number" },
        protein_g: { type: "number" }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              nutrition: { const: 1 }
            },
            required: ["nutrition"]
          }
        }
      },
      then: {
        required: ["nutrition"]
      }
    },
    {
      if: {
        required: ["nutrition"]
      },
      then: {
        required: ["stacks"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              nutrition: { const: 1 }
            },
            required: ["nutrition"]
          }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/schemas/recipe/stacks/schedule/1.schema.json
var schema_default4 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/schedule/1.schema.json",
  title: "Soustack Recipe Stack: schedule v1",
  description: "Schema for the schedule stack. Enforces bidirectional stack gating and restricts usage to the core profile.",
  type: "object",
  properties: {
    profile: { type: "string" },
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    schedule: {
      type: "object",
      properties: {
        tasks: { type: "array" }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              schedule: { const: 1 }
            },
            required: ["schedule"]
          }
        }
      },
      then: {
        required: ["schedule", "profile"],
        properties: {
          profile: { const: "core" }
        }
      }
    },
    {
      if: {
        required: ["schedule"]
      },
      then: {
        required: ["stacks", "profile"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              schedule: { const: 1 }
            },
            required: ["schedule"]
          },
          profile: { const: "core" }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/schemas/recipe/stacks/taxonomy/1.schema.json
var schema_default5 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/taxonomy/1.schema.json",
  title: "Soustack Recipe Stack: taxonomy v1",
  description: "Schema for the taxonomy stack. Enforces keyword and categorization data when enabled and ensures stack declaration accompanies the namespace block.",
  type: "object",
  properties: {
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    taxonomy: {
      type: "object",
      properties: {
        keywords: { type: "array", items: { type: "string" } },
        category: { type: "string" },
        cuisine: { type: "string" }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              taxonomy: { const: 1 }
            },
            required: ["taxonomy"]
          }
        }
      },
      then: {
        required: ["taxonomy"]
      }
    },
    {
      if: {
        required: ["taxonomy"]
      },
      then: {
        required: ["stacks"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              taxonomy: { const: 1 }
            },
            required: ["taxonomy"]
          }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/schemas/recipe/stacks/times/1.schema.json
var schema_default6 = {
  $schema: "http://json-schema.org/draft-07/schema#",
  $id: "https://soustack.org/schemas/recipe/stacks/times/1.schema.json",
  title: "Soustack Recipe Stack: times v1",
  description: "Schema for the times stack. Maintains alignment between stack declarations and timing payloads.",
  type: "object",
  properties: {
    stacks: {
      type: "object",
      additionalProperties: {
        type: "integer",
        minimum: 1
      }
    },
    times: {
      type: "object",
      properties: {
        prepMinutes: { type: "number" },
        cookMinutes: { type: "number" },
        totalMinutes: { type: "number" }
      },
      additionalProperties: false
    }
  },
  allOf: [
    {
      if: {
        properties: {
          stacks: {
            type: "object",
            properties: {
              times: { const: 1 }
            },
            required: ["times"]
          }
        }
      },
      then: {
        required: ["times"]
      }
    },
    {
      if: {
        required: ["times"]
      },
      then: {
        required: ["stacks"],
        properties: {
          stacks: {
            type: "object",
            properties: {
              times: { const: 1 }
            },
            required: ["times"]
          }
        }
      }
    }
  ],
  additionalProperties: true
};

// src/validator.ts
var LEGACY_ROOT_SCHEMA_ID = "http://soustack.org/schema/v0.3.0";
var DEFAULT_ROOT_SCHEMA_ID = "https://soustack.spec/soustack.schema.json";
var BASE_SCHEMA_ID = "http://soustack.org/schema/recipe/base.schema.json";
var PROFILE_SCHEMA_PREFIX = "http://soustack.org/schema/recipe/profiles/";
var validationContexts = /* @__PURE__ */ new Map();
function loadAllSchemas(ajv) {
  const schemas = [
    soustack_schema_default,
    base_schema_default,
    minimal_schema_default,
    core_schema_default,
    base_schema_default2,
    cookable_schema_default,
    illustrated_schema_default,
    quantified_schema_default,
    scalable_schema_default,
    schedulable_schema_default,
    schema_default,
    schema_default2,
    schema_default3,
    schema_default4,
    schema_default5,
    schema_default6
  ];
  for (const schema of schemas) {
    if (schema && typeof schema === "object" && "$id" in schema) {
      const schemaWithId = schema;
      if (schemaWithId.$id) {
        ajv.addSchema(schemaWithId, schemaWithId.$id);
      }
    }
  }
  ajv.addSchema(
    {
      $id: DEFAULT_ROOT_SCHEMA_ID,
      allOf: [
        { $ref: LEGACY_ROOT_SCHEMA_ID },
        {
          type: "object",
          properties: {
            $schema: { const: DEFAULT_ROOT_SCHEMA_ID }
          }
        }
      ]
    },
    DEFAULT_ROOT_SCHEMA_ID
  );
}
function createContext(collectAllErrors) {
  const ajv = new Ajv2020__default.default({
    strict: false,
    allErrors: collectAllErrors,
    validateSchema: false
    // Don't validate schemas themselves
  });
  addFormats__default.default(ajv);
  loadAllSchemas(ajv);
  const rootValidator = ajv.getSchema(DEFAULT_ROOT_SCHEMA_ID) || ajv.getSchema(LEGACY_ROOT_SCHEMA_ID);
  const baseValidator = ajv.getSchema(BASE_SCHEMA_ID);
  return {
    ajv,
    rootValidator: rootValidator || void 0,
    baseValidator: baseValidator || void 0,
    validators: /* @__PURE__ */ new Map()
  };
}
function getContext(collectAllErrors) {
  if (!validationContexts.has(collectAllErrors)) {
    validationContexts.set(collectAllErrors, createContext(collectAllErrors));
  }
  return validationContexts.get(collectAllErrors);
}
function cloneRecipe(recipe) {
  if (typeof structuredClone === "function") {
    return structuredClone(recipe);
  }
  return JSON.parse(JSON.stringify(recipe));
}
function formatAjvError(error) {
  var _a;
  let path = error.instancePath || "/";
  if (error.keyword === "additionalProperties" && ((_a = error.params) == null ? void 0 : _a.additionalProperty)) {
    const extra = error.params.additionalProperty;
    path = `${error.instancePath || ""}/${extra}`.replace(/\/+/g, "/") || "/";
  }
  return {
    path,
    keyword: error.keyword,
    message: error.message || "Validation error"
  };
}
function isSoustackSchemaId(schemaId) {
  return schemaId.startsWith("http://soustack.org/schema") || schemaId.startsWith("https://soustack.org/schema") || schemaId.startsWith("https://soustack.spec/") || schemaId.startsWith("https://soustack.org/schemas/");
}
function inferStacksFromPayload(recipe) {
  const inferred = {};
  const payloadToStack = {
    attribution: "attribution",
    taxonomy: "taxonomy",
    media: "media",
    times: "times",
    nutrition: "nutrition",
    schedule: "schedule"
  };
  for (const [field, stackName] of Object.entries(payloadToStack)) {
    if (recipe && typeof recipe === "object" && field in recipe && recipe[field] !== void 0) {
      inferred[stackName] = 1;
    }
  }
  return inferred;
}
function getComposedValidator(profile, stacks, context) {
  const stackIdentifiers = Object.entries(stacks).map(([name, version]) => `${name}@${version}`).sort();
  const cacheKey = `${profile}::${stackIdentifiers.join(",")}`;
  const cached = context.validators.get(cacheKey);
  if (cached) return cached;
  const allOf = [{ $ref: BASE_SCHEMA_ID }];
  if (!context.ajv.getSchema(BASE_SCHEMA_ID)) {
    throw new Error(`Base schema not loaded: ${BASE_SCHEMA_ID}. Ensure schemas are loaded before creating validators.`);
  }
  const profileSchemaId = `${PROFILE_SCHEMA_PREFIX}${profile}.schema.json`;
  if (!context.ajv.getSchema(profileSchemaId)) {
    throw new Error(`Profile schema not loaded: ${profileSchemaId}`);
  }
  allOf.push({ $ref: profileSchemaId });
  for (const [name, version] of Object.entries(stacks)) {
    if (typeof version === "number" && version >= 1) {
      const stackSchemaId = `https://soustack.org/schemas/recipe/stacks/${name}/${version}.schema.json`;
      if (!context.ajv.getSchema(stackSchemaId)) {
        throw new Error(`Stack schema not loaded: ${stackSchemaId}`);
      }
      allOf.push({ $ref: stackSchemaId });
    }
  }
  const composedSchema = {
    $id: `urn:soustack:composed:${cacheKey}`,
    allOf
  };
  const validateFn = context.ajv.compile(composedSchema);
  context.validators.set(cacheKey, validateFn);
  return validateFn;
}
function validateRecipeSchemaNormalized(normalizedInput, inputHasStacks, collectAllErrors, schemaOverride) {
  const normalized = cloneRecipe(normalizedInput);
  const context = getContext(collectAllErrors);
  const schemaId = typeof schemaOverride === "string" ? schemaOverride : typeof normalized.$schema === "string" ? normalized.$schema : void 0;
  const hasSchemaOverride = typeof schemaOverride === "string";
  const isSoustackSchema = schemaId ? isSoustackSchemaId(schemaId) : false;
  if (schemaId && isSoustackSchema) {
    const schemaValidator = context.ajv.getSchema(schemaId);
    if (!schemaValidator) {
      return {
        ok: false,
        errors: [
          {
            path: "/$schema",
            message: `Unknown schema: ${schemaId}`
          }
        ]
      };
    }
    const schemaInput = cloneRecipe(normalized);
    if (hasSchemaOverride && "$schema" in schemaInput && schemaInput.$schema !== schemaId) {
      delete schemaInput.$schema;
    }
    const isLegacySchema = schemaId.startsWith(LEGACY_ROOT_SCHEMA_ID);
    const shouldRemoveStacks = (isLegacySchema || schemaId === DEFAULT_ROOT_SCHEMA_ID) && !inputHasStacks;
    if (isLegacySchema && "@type" in schemaInput) {
      delete schemaInput["@type"];
    }
    if (shouldRemoveStacks && "stacks" in schemaInput) {
      delete schemaInput.stacks;
    }
    const schemaValid = schemaValidator(schemaInput);
    const schemaErrors = schemaValidator.errors || [];
    return {
      ok: !!schemaValid,
      errors: schemaErrors.map(formatAjvError)
    };
  }
  const hasProfile = normalized.profile && typeof normalized.profile === "string";
  let declaredStacks = {};
  if (normalized.stacks && typeof normalized.stacks === "object" && !Array.isArray(normalized.stacks)) {
    for (const [name, version] of Object.entries(normalized.stacks)) {
      if (typeof version === "number" && version >= 1) {
        declaredStacks[name] = version;
      }
    }
  }
  const inferredStacks = inferStacksFromPayload(normalized);
  const allStacks = { ...declaredStacks };
  for (const [name, version] of Object.entries(inferredStacks)) {
    if (!allStacks[name] || allStacks[name] < version) {
      allStacks[name] = version;
    }
  }
  let isValid;
  let errors = [];
  const profile = hasProfile ? normalized.profile.toLowerCase() : "core";
  const profileSchemaId = `${PROFILE_SCHEMA_PREFIX}${profile}.schema.json`;
  if (!context.ajv.getSchema(profileSchemaId)) {
    return {
      ok: false,
      errors: [
        {
          path: "/profile",
          message: `Profile schema not loaded: ${profileSchemaId}`
        }
      ]
    };
  }
  {
    const validationCopy = cloneRecipe(normalized);
    if (!validationCopy.stacks || typeof validationCopy.stacks !== "object" || Array.isArray(validationCopy.stacks)) {
      validationCopy.stacks = declaredStacks;
    }
    if (!validationCopy.profile) {
      validationCopy.profile = profile;
    }
    const validator = getComposedValidator(profile, allStacks, context);
    isValid = validator(validationCopy);
    errors = validator.errors || [];
    if (isValid && context.rootValidator) {
      const rootCheckCopy = cloneRecipe(normalized);
      if ("@type" in rootCheckCopy) {
        delete rootCheckCopy["@type"];
      }
      if ("stacks" in rootCheckCopy) {
        delete rootCheckCopy.stacks;
      }
      if ("profile" in rootCheckCopy) {
        delete rootCheckCopy.profile;
      }
      const stackPayloadFields = ["attribution", "taxonomy", "media", "times", "nutrition", "schedule"];
      for (const field of stackPayloadFields) {
        if (field in rootCheckCopy) {
          delete rootCheckCopy[field];
        }
      }
      const rootValid = context.rootValidator(rootCheckCopy);
      if (!rootValid && context.rootValidator.errors) {
        const unknownKeyErrors = context.rootValidator.errors.filter(
          (e) => e.keyword === "additionalProperties" && (e.instancePath === "" || e.instancePath === "/")
        );
        const schemaConstErrors = context.rootValidator.errors.filter(
          (e) => e.keyword === "const" && e.instancePath === "/$schema"
        );
        const relevantErrors = [...unknownKeyErrors, ...schemaConstErrors];
        if (relevantErrors.length > 0) {
          errors.push(...relevantErrors);
          isValid = false;
        }
      }
    }
  }
  return {
    ok: isValid,
    errors: errors.map(formatAjvError)
  };
}
function validateRecipe(input, options = {}) {
  var _a, _b;
  const { recipe: normalized, warnings } = normalizeRecipe(input);
  if (options.profile) {
    normalized.profile = options.profile;
  }
  const inputHasStacks = !!input && typeof input === "object" && !Array.isArray(input) && "stacks" in input;
  const { ok: schemaOk, errors: schemaErrors } = validateRecipeSchemaNormalized(
    normalized,
    inputHasStacks,
    (_a = options.collectAllErrors) != null ? _a : true,
    options.schema
  );
  const mode = (_b = options.mode) != null ? _b : "full";
  let conformanceIssues = [];
  let conformanceOk = true;
  if (mode === "full") {
    if (schemaOk) {
      const conformanceResult = validateConformance(normalized);
      conformanceIssues = conformanceResult.issues;
      conformanceOk = conformanceResult.ok;
    } else {
      conformanceOk = false;
    }
  }
  const ok = schemaOk && (mode === "schema" ? true : conformanceOk);
  const normalizedRecipe = ok || options.includeNormalized ? normalized : void 0;
  return {
    ok,
    schemaErrors,
    conformanceIssues,
    warnings,
    normalizedRecipe
  };
}
function detectProfiles(recipe) {
  const result = validateRecipe(recipe, { collectAllErrors: false });
  if (!result.ok) return [];
  return ["core"];
}

// src/converters/yield.ts
function parseYield(value) {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (typeof value === "number") {
    return {
      amount: value,
      unit: "servings"
    };
  }
  if (Array.isArray(value)) {
    return parseYield(value[0]);
  }
  if (typeof value === "object") {
    const maybeYield = value;
    if (typeof maybeYield.amount === "number") {
      return {
        amount: maybeYield.amount,
        unit: typeof maybeYield.unit === "string" ? maybeYield.unit : "servings",
        description: typeof maybeYield.description === "string" ? maybeYield.description : void 0
      };
    }
  }
  if (typeof value === "string") {
    const trimmed = value.trim();
    const match = trimmed.match(/(\d+(?:\.\d+)?)/);
    if (match) {
      const amount = parseFloat(match[1]);
      const unit = trimmed.slice(match.index + match[1].length).trim();
      return {
        amount,
        unit: unit || "servings",
        description: trimmed
      };
    }
  }
  return void 0;
}
function formatYield(yieldValue) {
  var _a;
  if (!yieldValue) return void 0;
  if (!yieldValue.amount && !yieldValue.unit) {
    return void 0;
  }
  const amount = (_a = yieldValue.amount) != null ? _a : "";
  const unit = yieldValue.unit ? ` ${yieldValue.unit}` : "";
  return `${amount}${unit}`.trim() || yieldValue.description;
}

// src/utils/image.ts
function normalizeImage(image) {
  if (!image) {
    return void 0;
  }
  if (typeof image === "string") {
    const trimmed = image.trim();
    return trimmed || void 0;
  }
  if (Array.isArray(image)) {
    const urls = image.map((entry) => typeof entry === "string" ? entry.trim() : extractUrl(entry)).filter((url) => typeof url === "string" && Boolean(url));
    if (urls.length === 0) {
      return void 0;
    }
    if (urls.length === 1) {
      return urls[0];
    }
    return urls;
  }
  return extractUrl(image);
}
function extractUrl(value) {
  if (!value || typeof value !== "object") {
    return void 0;
  }
  const record = value;
  const candidate = typeof record.url === "string" ? record.url : typeof record.contentUrl === "string" ? record.contentUrl : void 0;
  if (!candidate) {
    return void 0;
  }
  const trimmed = candidate.trim();
  return trimmed || void 0;
}

// src/fromSchemaOrg.ts
function fromSchemaOrg(input) {
  var _a;
  const recipeNode = extractRecipeNode(input);
  if (!recipeNode) {
    return null;
  }
  const ingredients = convertIngredients(recipeNode.recipeIngredient);
  const instructions = convertInstructions(recipeNode.recipeInstructions);
  const time = convertTime(recipeNode);
  const recipeYield = parseYield(recipeNode.recipeYield);
  const tags = collectTags(recipeNode.recipeCuisine, recipeNode.keywords);
  const category = extractFirst(recipeNode.recipeCategory);
  const source = convertSource(recipeNode);
  const dateModified = recipeNode.dateModified || void 0;
  const nutrition = convertNutrition(recipeNode.nutrition);
  const attribution = convertAttribution(recipeNode);
  const taxonomy = convertTaxonomy(tags, category, extractFirst(recipeNode.recipeCuisine));
  const media = convertMedia(recipeNode.image, recipeNode.video);
  const times = convertTimes(time);
  const stacks = {};
  if (attribution) stacks.attribution = 1;
  if (taxonomy) stacks.taxonomy = 1;
  if (media) stacks.media = 1;
  if (nutrition) stacks.nutrition = 1;
  if (times) stacks.times = 1;
  const rawRecipe = {
    "@type": "Recipe",
    profile: "minimal",
    stacks,
    name: recipeNode.name.trim(),
    description: ((_a = recipeNode.description) == null ? void 0 : _a.trim()) || void 0,
    image: normalizeImage(recipeNode.image),
    category,
    tags: tags.length ? tags : void 0,
    source,
    dateAdded: recipeNode.datePublished || void 0,
    yield: recipeYield,
    time,
    ingredients,
    instructions,
    ...dateModified ? { dateModified } : {},
    ...nutrition ? { nutrition } : {},
    ...attribution ? { attribution } : {},
    ...taxonomy ? { taxonomy } : {},
    ...media ? { media } : {},
    ...times ? { times } : {}
  };
  const { recipe } = normalizeRecipe(rawRecipe);
  return recipe;
}
function extractRecipeNode(input) {
  if (!input) return null;
  if (Array.isArray(input)) {
    for (const entry of input) {
      const found = extractRecipeNode(entry);
      if (found) {
        return found;
      }
    }
    return null;
  }
  if (typeof input !== "object") {
    return null;
  }
  const record = input;
  if (record["@graph"]) {
    const fromGraph = extractRecipeNode(record["@graph"]);
    if (fromGraph) {
      return fromGraph;
    }
  }
  if (!hasRecipeType(record["@type"])) {
    return null;
  }
  if (!isValidName(record.name)) {
    return null;
  }
  return record;
}
function hasRecipeType(value) {
  if (!value) return false;
  const types = Array.isArray(value) ? value : [value];
  return types.some(
    (entry) => typeof entry === "string" && entry.toLowerCase() === "recipe"
  );
}
function isValidName(name) {
  return typeof name === "string" && Boolean(name.trim());
}
function convertIngredients(value) {
  if (!value) return [];
  const normalized = Array.isArray(value) ? value : [value];
  return normalized.map((item) => typeof item === "string" ? item.trim() : "").filter(Boolean);
}
function convertInstructions(value) {
  var _a;
  if (!value) return [];
  const normalized = Array.isArray(value) ? value : [value];
  const result = [];
  for (const entry of normalized) {
    if (!entry) continue;
    if (typeof entry === "string") {
      const text = entry.trim();
      if (text) {
        result.push(text);
      }
      continue;
    }
    if (isHowToSection(entry)) {
      const subsectionItems = extractSectionItems(entry.itemListElement);
      if (subsectionItems.length) {
        result.push({
          subsection: ((_a = entry.name) == null ? void 0 : _a.trim()) || "Section",
          items: subsectionItems
        });
      }
      continue;
    }
    if (isHowToStep(entry)) {
      const parsed = convertHowToStep(entry);
      if (parsed) {
        result.push(parsed);
      }
    }
  }
  return result;
}
function extractSectionItems(items = []) {
  const result = [];
  for (const item of items) {
    if (!item) continue;
    if (typeof item === "string") {
      const text = item.trim();
      if (text) {
        result.push(text);
      }
      continue;
    }
    if (isHowToStep(item)) {
      const parsed = convertHowToStep(item);
      if (parsed) {
        result.push(parsed);
      }
      continue;
    }
    if (isHowToSection(item)) {
      result.push(...extractSectionItems(item.itemListElement));
    }
  }
  return result;
}
function extractInstructionText(value) {
  const text = typeof value.text === "string" ? value.text : value.name;
  return typeof text === "string" ? text.trim() || void 0 : void 0;
}
function convertHowToStep(step) {
  const text = extractInstructionText(step);
  if (!text) {
    return void 0;
  }
  const normalizedImage = normalizeImage(step.image);
  const image = Array.isArray(normalizedImage) ? normalizedImage[0] : normalizedImage;
  const id = extractInstructionId(step);
  const timing = extractInstructionTiming(step);
  if (!image && !id && !timing) {
    return text;
  }
  const instruction = { text };
  if (id) instruction.id = id;
  if (image) instruction.image = image;
  if (timing) instruction.timing = timing;
  return instruction;
}
function extractInstructionTiming(step) {
  const duration = step.totalTime || step.performTime || step.prepTime || step.duration;
  if (!duration || typeof duration !== "string") {
    return void 0;
  }
  const parsed = smartParseDuration(duration);
  return { duration: parsed != null ? parsed : duration, type: "active" };
}
function extractInstructionId(step) {
  const raw = step["@id"] || step.id || step.url;
  if (typeof raw !== "string") {
    return void 0;
  }
  const trimmed = raw.trim();
  return trimmed || void 0;
}
function isHowToStep(value) {
  return Boolean(value) && typeof value === "object" && value["@type"] === "HowToStep";
}
function isHowToSection(value) {
  return Boolean(value) && typeof value === "object" && value["@type"] === "HowToSection" && Array.isArray(value.itemListElement);
}
function convertTime(recipe) {
  var _a, _b, _c;
  const prep = smartParseDuration((_a = recipe.prepTime) != null ? _a : "");
  const cook = smartParseDuration((_b = recipe.cookTime) != null ? _b : "");
  const total = smartParseDuration((_c = recipe.totalTime) != null ? _c : "");
  const structured = {};
  if (prep !== null && prep !== void 0) structured.prep = prep;
  if (cook !== null && cook !== void 0) structured.active = cook;
  if (total !== null && total !== void 0) structured.total = total;
  return Object.keys(structured).length ? structured : void 0;
}
function collectTags(cuisine, keywords) {
  const tags = /* @__PURE__ */ new Set();
  flattenStrings(cuisine).forEach((tag) => tags.add(tag));
  if (typeof keywords === "string") {
    splitKeywords(keywords).forEach((tag) => tags.add(tag));
  } else {
    flattenStrings(keywords).forEach((tag) => tags.add(tag));
  }
  return Array.from(tags);
}
function splitKeywords(value) {
  return value.split(/[,|]/).map((part) => part.trim()).filter(Boolean);
}
function flattenStrings(value) {
  if (!value) return [];
  if (typeof value === "string") return [value.trim()].filter(Boolean);
  if (Array.isArray(value)) {
    return value.map((item) => typeof item === "string" ? item.trim() : "").filter(Boolean);
  }
  return [];
}
function extractFirst(value) {
  const arr = flattenStrings(value);
  return arr.length ? arr[0] : void 0;
}
function convertSource(recipe) {
  var _a;
  const author = extractEntityName(recipe.author);
  const publisher = extractEntityName(recipe.publisher);
  const url = (_a = recipe.url || recipe.mainEntityOfPage) == null ? void 0 : _a.trim();
  const source = {};
  if (author) source.author = author;
  if (publisher) source.name = publisher;
  if (url) source.url = url;
  return Object.keys(source).length ? source : void 0;
}
function extractEntityName(value) {
  if (!value) return void 0;
  if (typeof value === "string") {
    const trimmed = value.trim();
    return trimmed || void 0;
  }
  if (Array.isArray(value)) {
    for (const entry of value) {
      const name = extractEntityName(entry);
      if (name) {
        return name;
      }
    }
    return void 0;
  }
  if (typeof value === "object" && typeof value.name === "string") {
    const trimmed = value.name.trim();
    return trimmed || void 0;
  }
  return void 0;
}
function convertAttribution(recipe) {
  var _a, _b;
  const attribution = {};
  const url = (_a = recipe.url || recipe.mainEntityOfPage) == null ? void 0 : _a.trim();
  const author = extractEntityName(recipe.author);
  const datePublished = (_b = recipe.datePublished) == null ? void 0 : _b.trim();
  if (url) attribution.url = url;
  if (author) attribution.author = author;
  if (datePublished) attribution.datePublished = datePublished;
  return Object.keys(attribution).length ? attribution : void 0;
}
function convertTaxonomy(keywords, category, cuisine) {
  const taxonomy = {};
  if (keywords.length) taxonomy.keywords = keywords;
  if (category) taxonomy.category = category;
  if (cuisine) taxonomy.cuisine = cuisine;
  return Object.keys(taxonomy).length ? taxonomy : void 0;
}
function normalizeMediaList(value) {
  if (!value) return [];
  if (typeof value === "string") return [value.trim()].filter(Boolean);
  if (Array.isArray(value)) {
    return value.map((item) => typeof item === "string" ? item.trim() : extractMediaUrl(item)).filter((entry) => Boolean(entry == null ? void 0 : entry.length));
  }
  const url = extractMediaUrl(value);
  return url ? [url] : [];
}
function extractMediaUrl(value) {
  if (value && typeof value === "object" && "url" in value && typeof value.url === "string") {
    const trimmed = value.url.trim();
    return trimmed || void 0;
  }
  return void 0;
}
function convertMedia(image, video) {
  const normalizedImage = normalizeImage(image);
  const images = normalizedImage ? Array.isArray(normalizedImage) ? normalizedImage : [normalizedImage] : [];
  const videos = normalizeMediaList(video);
  const media = {};
  if (images.length) media.images = images;
  if (videos.length) media.videos = videos;
  return Object.keys(media).length ? media : void 0;
}
function convertTimes(time) {
  if (!time) return void 0;
  const times = {};
  if (typeof time.prep === "number") times.prepMinutes = time.prep;
  if (typeof time.active === "number") times.cookMinutes = time.active;
  if (typeof time.total === "number") times.totalMinutes = time.total;
  return Object.keys(times).length ? times : void 0;
}
function convertNutrition(nutrition) {
  if (!nutrition || typeof nutrition !== "object") {
    return void 0;
  }
  const result = {};
  let hasData = false;
  if ("calories" in nutrition) {
    const calories = nutrition.calories;
    if (typeof calories === "number") {
      result.calories = calories;
      hasData = true;
    } else if (typeof calories === "string") {
      const parsed = parseFloat(calories.replace(/[^\d.-]/g, ""));
      if (!isNaN(parsed)) {
        result.calories = parsed;
        hasData = true;
      }
    }
  }
  if ("proteinContent" in nutrition || "protein_g" in nutrition) {
    const protein = nutrition.proteinContent || nutrition.protein_g;
    if (typeof protein === "number") {
      result.protein_g = protein;
      hasData = true;
    } else if (typeof protein === "string") {
      const parsed = parseFloat(protein.replace(/[^\d.-]/g, ""));
      if (!isNaN(parsed)) {
        result.protein_g = parsed;
        hasData = true;
      }
    }
  }
  return hasData ? result : void 0;
}

// src/schemas/registry/stacks.json
var stacks_default = {
  stacks: [
    {
      id: "attribution",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/attribution",
      schema: "http://soustack.org/schema/v0.3.0/stacks/attribution",
      schemaOrgMappable: true,
      schemaOrgConfidence: "medium",
      minProfile: "minimal",
      allowedOnMinimal: true
    },
    {
      id: "taxonomy",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/taxonomy",
      schema: "http://soustack.org/schema/v0.3.0/stacks/taxonomy",
      schemaOrgMappable: true,
      schemaOrgConfidence: "high",
      minProfile: "minimal",
      allowedOnMinimal: true
    },
    {
      id: "media",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/media",
      schema: "http://soustack.org/schema/v0.3.0/stacks/media",
      schemaOrgMappable: true,
      schemaOrgConfidence: "medium",
      minProfile: "minimal",
      allowedOnMinimal: true
    },
    {
      id: "nutrition",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/nutrition",
      schema: "http://soustack.org/schema/v0.3.0/stacks/nutrition",
      schemaOrgMappable: false,
      schemaOrgConfidence: "low",
      minProfile: "minimal",
      allowedOnMinimal: true
    },
    {
      id: "times",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/times",
      schema: "http://soustack.org/schema/v0.3.0/stacks/times",
      schemaOrgMappable: true,
      schemaOrgConfidence: "medium",
      minProfile: "minimal",
      allowedOnMinimal: true
    },
    {
      id: "schedule",
      versions: [1],
      latest: 1,
      namespace: "http://soustack.org/schema/v0.3.0/stacks/schedule",
      schema: "http://soustack.org/schema/v0.3.0/stacks/schedule",
      schemaOrgMappable: false,
      schemaOrgConfidence: "low",
      minProfile: "core",
      allowedOnMinimal: false
    }
  ]
};

// src/converters/toSchemaOrg.ts
function convertBasicMetadata(recipe) {
  var _a;
  return cleanOutput({
    "@context": "https://schema.org",
    "@type": "Recipe",
    name: recipe.name,
    description: recipe.description,
    image: recipe.image,
    url: (_a = recipe.source) == null ? void 0 : _a.url,
    datePublished: recipe.dateAdded,
    dateModified: recipe.dateModified
  });
}
function convertIngredients2(ingredients = []) {
  const result = [];
  ingredients.forEach((ingredient) => {
    var _a;
    if (!ingredient) {
      return;
    }
    if (typeof ingredient === "string") {
      const value2 = ingredient.trim();
      if (value2) {
        result.push(value2);
      }
      return;
    }
    if ("subsection" in ingredient) {
      ingredient.items.forEach((item) => {
        if (!item) {
          return;
        }
        if (typeof item === "string") {
          const value2 = item.trim();
          if (value2) {
            result.push(value2);
          }
        } else if (item.item) {
          const value2 = item.item.trim();
          if (value2) {
            result.push(value2);
          }
        }
      });
      return;
    }
    const value = (_a = ingredient.item) == null ? void 0 : _a.trim();
    if (value) {
      result.push(value);
    }
  });
  return result;
}
function convertInstructions2(instructions = []) {
  return instructions.map((entry) => convertInstruction(entry)).filter((value) => Boolean(value));
}
function convertInstruction(entry) {
  if (!entry) {
    return null;
  }
  if (typeof entry === "string") {
    const value = entry.trim();
    return value || null;
  }
  if ("subsection" in entry) {
    const steps = entry.items.map((item) => convertInstruction(item)).filter((step) => Boolean(step));
    if (!steps.length) {
      return null;
    }
    return {
      "@type": "HowToSection",
      name: entry.subsection,
      itemListElement: steps
    };
  }
  if ("text" in entry) {
    return createHowToStep(entry);
  }
  return createHowToStep(String(entry));
}
function createHowToStep(entry) {
  var _a;
  if (!entry) return null;
  if (typeof entry === "string") {
    const trimmed2 = entry.trim();
    return trimmed2 || null;
  }
  const trimmed = (_a = entry.text) == null ? void 0 : _a.trim();
  if (!trimmed) {
    return null;
  }
  const step = {
    "@type": "HowToStep",
    text: trimmed
  };
  if (entry.id) {
    step["@id"] = entry.id;
  }
  if (entry.timing) {
    if (typeof entry.timing.duration === "number") {
      step.performTime = formatDuration(entry.timing.duration);
    } else if (entry.timing.duration) {
      step.performTime = entry.timing.duration;
    }
  }
  if (entry.image) {
    step.image = entry.image;
  }
  if (step["@id"] || step.performTime || step.image) {
    return step;
  }
  return trimmed;
}
function convertTime2(time) {
  if (!time) {
    return {};
  }
  if (isStructuredTime(time)) {
    const result2 = {};
    if (time.prep !== void 0) {
      result2.prepTime = formatDuration(time.prep);
    }
    if (time.active !== void 0) {
      result2.cookTime = formatDuration(time.active);
    }
    if (time.total !== void 0) {
      result2.totalTime = formatDuration(time.total);
    }
    return result2;
  }
  const result = {};
  if (time.prepTime) {
    result.prepTime = time.prepTime;
  }
  if (time.cookTime) {
    result.cookTime = time.cookTime;
  }
  return result;
}
function convertTimesModule(times) {
  if (!times) {
    return {};
  }
  const result = {};
  if (times.prepMinutes !== void 0) {
    result.prepTime = formatDuration(times.prepMinutes);
  }
  if (times.cookMinutes !== void 0) {
    result.cookTime = formatDuration(times.cookMinutes);
  }
  if (times.totalMinutes !== void 0) {
    result.totalTime = formatDuration(times.totalMinutes);
  }
  return result;
}
function convertYield(yld) {
  if (!yld) {
    return void 0;
  }
  return formatYield(yld);
}
function convertAuthor(source) {
  if (!source) {
    return {};
  }
  const result = {};
  if (source.author) {
    result.author = {
      "@type": "Person",
      name: source.author
    };
  }
  if (source.name) {
    result.publisher = {
      "@type": "Organization",
      name: source.name
    };
  }
  if (source.url) {
    result.url = source.url;
  }
  return result;
}
function convertCategoryTags(category, tags) {
  const result = {};
  if (category) {
    result.recipeCategory = category;
  }
  if (tags && tags.length > 0) {
    result.keywords = tags.filter(Boolean).join(", ");
  }
  return result;
}
function convertNutrition2(nutrition) {
  if (!nutrition) {
    return void 0;
  }
  const result = {
    "@type": "NutritionInformation"
  };
  if (nutrition.calories !== void 0) {
    if (typeof nutrition.calories === "number") {
      result.calories = `${nutrition.calories} calories`;
    } else {
      result.calories = nutrition.calories;
    }
  }
  Object.keys(nutrition).forEach((key) => {
    if (key !== "calories" && key !== "@type") {
      result[key] = nutrition[key];
    }
  });
  return result;
}
function cleanOutput(obj) {
  return Object.fromEntries(
    Object.entries(obj).filter(([, value]) => value !== void 0)
  );
}
function getSchemaOrgMappableStacks(stacks = {}) {
  const mappableStackIds = /* @__PURE__ */ new Set();
  const mappableFromRegistry = stacks_default.stacks.filter((stack) => stack.schemaOrgMappable).map((stack) => `${stack.id}@${stack.latest}`);
  for (const [name, version] of Object.entries(stacks)) {
    const stackId = `${name}@${version}`;
    if (mappableFromRegistry.includes(stackId)) {
      mappableStackIds.add(stackId);
    }
  }
  return mappableStackIds;
}
function toSchemaOrg(recipe) {
  const base = convertBasicMetadata(recipe);
  const ingredients = convertIngredients2(recipe.ingredients);
  const instructions = convertInstructions2(recipe.instructions);
  const recipeStacks = recipe.stacks && typeof recipe.stacks === "object" && !Array.isArray(recipe.stacks) ? recipe.stacks : {};
  const mappableStacks = getSchemaOrgMappableStacks(recipeStacks);
  const hasMappableNutrition = mappableStacks.has("nutrition@1");
  const nutrition = hasMappableNutrition ? convertNutrition2(recipe.nutrition) : void 0;
  const hasMappableTimes = mappableStacks.has("times@1");
  const timeData = hasMappableTimes ? recipe.times ? convertTimesModule(recipe.times) : convertTime2(recipe.time) : {};
  const hasMappableAttribution = mappableStacks.has("attribution@1");
  const attributionData = hasMappableAttribution ? convertAuthor(recipe.source) : {};
  const hasMappableTaxonomy = mappableStacks.has("taxonomy@1");
  const taxonomyData = hasMappableTaxonomy ? convertCategoryTags(recipe.category, recipe.tags) : {};
  return cleanOutput({
    ...base,
    recipeIngredient: ingredients.length ? ingredients : void 0,
    recipeInstructions: instructions.length ? instructions : void 0,
    recipeYield: convertYield(recipe.yield),
    ...timeData,
    ...attributionData,
    ...taxonomyData,
    nutrition
  });
}
function isStructuredTime(time) {
  return typeof time.prep !== "undefined" || typeof time.active !== "undefined" || typeof time.passive !== "undefined" || typeof time.total !== "undefined";
}

// src/scraper/extractors/utils.ts
var RECIPE_TYPES = /* @__PURE__ */ new Set([
  "recipe",
  "https://schema.org/recipe",
  "http://schema.org/recipe"
]);
function isRecipeNode(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const type = value["@type"];
  if (typeof type === "string") {
    return RECIPE_TYPES.has(type.toLowerCase());
  }
  if (Array.isArray(type)) {
    return type.some(
      (entry) => typeof entry === "string" && RECIPE_TYPES.has(entry.toLowerCase())
    );
  }
  return false;
}
function safeJsonParse(content) {
  try {
    return JSON.parse(content);
  } catch {
    return null;
  }
}
function normalizeText(value) {
  if (!value) return void 0;
  const trimmed = value.replace(/\s+/g, " ").trim();
  return trimmed || void 0;
}

// src/scraper/extractors/browser.ts
var SIMPLE_PROPS = ["name", "description", "image", "recipeYield", "prepTime", "cookTime", "totalTime"];
function extractRecipeBrowser(html) {
  const jsonLdRecipe = extractJsonLdBrowser(html);
  if (jsonLdRecipe) {
    return { recipe: jsonLdRecipe, source: "jsonld" };
  }
  const microdataRecipe = extractMicrodataBrowser(html);
  if (microdataRecipe) {
    return { recipe: microdataRecipe, source: "microdata" };
  }
  return { recipe: null, source: null };
}
function extractJsonLdBrowser(html) {
  var _a;
  if (typeof globalThis.DOMParser === "undefined") {
    return null;
  }
  const parser = new globalThis.DOMParser();
  const doc = parser.parseFromString(html, "text/html");
  const scripts = doc.querySelectorAll('script[type="application/ld+json"]');
  const candidates = [];
  scripts.forEach((script) => {
    const content = script.textContent;
    if (!content) return;
    const parsed = safeJsonParse(content);
    if (!parsed) return;
    collectCandidates(parsed, candidates);
  });
  return (_a = candidates[0]) != null ? _a : null;
}
function extractMicrodataBrowser(html) {
  if (typeof globalThis.DOMParser === "undefined") {
    return null;
  }
  const parser = new globalThis.DOMParser();
  const doc = parser.parseFromString(html, "text/html");
  const recipeEl = doc.querySelector('[itemscope][itemtype*="schema.org/Recipe"]');
  if (!recipeEl) {
    return null;
  }
  const recipe = {
    "@type": "Recipe"
  };
  SIMPLE_PROPS.forEach((prop) => {
    const value = findPropertyValue(recipeEl, prop);
    if (value) {
      recipe[prop] = value;
    }
  });
  const ingredients = [];
  recipeEl.querySelectorAll('[itemprop="recipeIngredient"]').forEach((el) => {
    const text = normalizeText(
      el.getAttribute("content") || el.textContent || void 0
    );
    if (text) ingredients.push(text);
  });
  if (ingredients.length) {
    recipe.recipeIngredient = ingredients;
  }
  const instructions = [];
  recipeEl.querySelectorAll('[itemprop="recipeInstructions"]').forEach((el) => {
    var _a;
    const text = normalizeText(el.getAttribute("content")) || normalizeText(((_a = el.querySelector('[itemprop="text"]')) == null ? void 0 : _a.textContent) || void 0) || normalizeText(el.textContent || void 0);
    if (text) instructions.push(text);
  });
  if (instructions.length) {
    recipe.recipeInstructions = instructions;
  }
  if (recipe.name || ingredients.length) {
    return recipe;
  }
  return null;
}
function findPropertyValue(context, prop) {
  const node = context.querySelector(`[itemprop="${prop}"]`);
  if (!node) return void 0;
  return normalizeText(node.getAttribute("content")) || normalizeText(node.getAttribute("href")) || normalizeText(node.getAttribute("src")) || normalizeText(node.textContent || void 0);
}
function collectCandidates(payload, bucket) {
  if (!payload) return;
  if (Array.isArray(payload)) {
    payload.forEach((entry) => collectCandidates(entry, bucket));
    return;
  }
  if (typeof payload !== "object") {
    return;
  }
  if (isRecipeNode(payload)) {
    bucket.push(payload);
    return;
  }
  const graph = payload["@graph"];
  if (Array.isArray(graph)) {
    graph.forEach((entry) => collectCandidates(entry, bucket));
  }
}

// src/scraper/browser.ts
function extractSchemaOrgRecipeFromHTML(html) {
  const { recipe } = extractRecipeBrowser(html);
  return recipe;
}

// src/specVersion.ts
var SOUSTACK_SPEC_VERSION = "0.3.0";

// src/conversion/units.ts
var MASS_UNITS = {
  g: {
    dimension: "mass",
    toMetricBase: 1,
    metricBaseUnit: "g",
    isMetric: true
  },
  kg: {
    dimension: "mass",
    toMetricBase: 1e3,
    metricBaseUnit: "g",
    isMetric: true
  },
  oz: {
    dimension: "mass",
    toMetricBase: 28.349523125,
    metricBaseUnit: "g",
    isMetric: false
  },
  lb: {
    dimension: "mass",
    toMetricBase: 453.59237,
    metricBaseUnit: "g",
    isMetric: false
  }
};
var VOLUME_UNITS = {
  ml: {
    dimension: "volume",
    toMetricBase: 1,
    metricBaseUnit: "ml",
    isMetric: true
  },
  l: {
    dimension: "volume",
    toMetricBase: 1e3,
    metricBaseUnit: "ml",
    isMetric: true
  },
  tsp: {
    dimension: "volume",
    toMetricBase: 4.92892159375,
    metricBaseUnit: "ml",
    isMetric: false
  },
  tbsp: {
    dimension: "volume",
    toMetricBase: 14.78676478125,
    metricBaseUnit: "ml",
    isMetric: false
  },
  fl_oz: {
    dimension: "volume",
    toMetricBase: 29.5735295625,
    metricBaseUnit: "ml",
    isMetric: false
  },
  cup: {
    dimension: "volume",
    toMetricBase: 236.5882365,
    metricBaseUnit: "ml",
    isMetric: false
  },
  pint: {
    dimension: "volume",
    toMetricBase: 473.176473,
    metricBaseUnit: "ml",
    isMetric: false
  },
  quart: {
    dimension: "volume",
    toMetricBase: 946.352946,
    metricBaseUnit: "ml",
    isMetric: false
  },
  gallon: {
    dimension: "volume",
    toMetricBase: 3785.411784,
    metricBaseUnit: "ml",
    isMetric: false
  }
};
var COUNT_UNITS = {
  clove: {
    dimension: "count",
    toMetricBase: 1,
    metricBaseUnit: "count",
    isMetric: true
  },
  sprig: {
    dimension: "count",
    toMetricBase: 1,
    metricBaseUnit: "count",
    isMetric: true
  },
  leaf: {
    dimension: "count",
    toMetricBase: 1,
    metricBaseUnit: "count",
    isMetric: true
  },
  pinch: {
    dimension: "count",
    toMetricBase: 1,
    metricBaseUnit: "count",
    isMetric: true
  },
  bottle: {
    dimension: "count",
    toMetricBase: 1,
    metricBaseUnit: "count",
    isMetric: true
  },
  count: {
    dimension: "count",
    toMetricBase: 1,
    metricBaseUnit: "count",
    isMetric: true
  }
};
var UNIT_DEFINITIONS = {
  ...MASS_UNITS,
  ...VOLUME_UNITS,
  ...COUNT_UNITS
};
function normalizeUnitToken(unit) {
  var _a;
  if (!unit) {
    return null;
  }
  const token = unit.trim().toLowerCase().replace(/[\s-]+/g, "_");
  const canonical = (_a = UNIT_SYNONYMS[token]) != null ? _a : token;
  return canonical in UNIT_DEFINITIONS ? canonical : null;
}
var UNIT_SYNONYMS = {
  teaspoons: "tsp",
  teaspoon: "tsp",
  tsps: "tsp",
  tbsp: "tbsp",
  tbsps: "tbsp",
  tablespoon: "tbsp",
  tablespoons: "tbsp",
  cup: "cup",
  cups: "cup",
  pint: "pint",
  pints: "pint",
  quart: "quart",
  quarts: "quart",
  gallon: "gallon",
  gallons: "gallon",
  ml: "ml",
  milliliter: "ml",
  milliliters: "ml",
  millilitre: "ml",
  millilitres: "ml",
  l: "l",
  liter: "l",
  liters: "l",
  litre: "l",
  litres: "l",
  fl_oz: "fl_oz",
  "fl.oz": "fl_oz",
  "fl.oz.": "fl_oz",
  "fl_oz.": "fl_oz",
  "fl oz": "fl_oz",
  "fl oz.": "fl_oz",
  fluid_ounce: "fl_oz",
  fluid_ounces: "fl_oz",
  oz: "oz",
  ounce: "oz",
  ounces: "oz",
  lb: "lb",
  lbs: "lb",
  pound: "lb",
  pounds: "lb",
  g: "g",
  gram: "g",
  grams: "g",
  kg: "kg",
  kilogram: "kg",
  kilograms: "kg",
  clove: "clove",
  cloves: "clove",
  sprig: "sprig",
  sprigs: "sprig",
  leaf: "leaf",
  leaves: "leaf",
  pinch: "pinch",
  pinches: "pinch",
  bottle: "bottle",
  bottles: "bottle",
  count: "count",
  counts: "count"
};
function convertToMetricBase(quantity, unit) {
  const definition = UNIT_DEFINITIONS[unit];
  const quantityInMetricBase = quantity * definition.toMetricBase;
  return {
    quantity: quantityInMetricBase,
    baseUnit: definition.metricBaseUnit,
    definition
  };
}

// src/conversion/convertLineItem.ts
var UnknownUnitError = class extends Error {
  constructor(unit) {
    super(`Unknown unit "${unit}".`);
    this.unit = unit;
    this.name = "UnknownUnitError";
  }
};
var UnsupportedConversionError = class extends Error {
  constructor(unit, mode) {
    super(`Cannot convert unit "${unit}" in ${mode} mode.`);
    this.unit = unit;
    this.mode = mode;
    this.name = "UnsupportedConversionError";
  }
};
var MissingEquivalencyError = class extends Error {
  constructor(ingredient, unit) {
    super(
      `No volume to mass equivalency for "${ingredient}" (${unit}).`
    );
    this.ingredient = ingredient;
    this.unit = unit;
    this.name = "MissingEquivalencyError";
  }
};
var VOLUME_TO_MASS_EQUIV_G_PER_UNIT = {
  flour: {
    cup: 120
  }
};
var DEFAULT_ROUND_MODE = "sane";
function convertLineItemToMetric(item, mode, opts) {
  var _a, _b, _c, _d;
  const roundMode = (_a = opts == null ? void 0 : opts.round) != null ? _a : DEFAULT_ROUND_MODE;
  const normalizedUnit = normalizeUnitToken(item.unit);
  if (!normalizedUnit) {
    if (!item.unit || item.unit.trim() === "") {
      return item;
    }
    throw new UnknownUnitError(item.unit);
  }
  const definition = UNIT_DEFINITIONS[normalizedUnit];
  if (definition.dimension === "count") {
    return item;
  }
  if (mode === "volume") {
    if (definition.dimension !== "volume") {
      throw new UnsupportedConversionError((_b = item.unit) != null ? _b : "", mode);
    }
    const { quantity, unit } = finalizeMetricVolume(
      convertToMetricBase(item.quantity, normalizedUnit).quantity,
      roundMode
    );
    return {
      ...item,
      quantity,
      unit
    };
  }
  if (definition.dimension === "mass") {
    const { quantity, unit } = finalizeMetricMass(
      convertToMetricBase(item.quantity, normalizedUnit).quantity,
      roundMode
    );
    return {
      ...item,
      quantity,
      unit
    };
  }
  if (definition.dimension !== "volume") {
    throw new UnsupportedConversionError((_c = item.unit) != null ? _c : "", mode);
  }
  const gramsPerUnit = lookupEquivalency(
    item.ingredient,
    normalizedUnit
  );
  if (!gramsPerUnit) {
    throw new MissingEquivalencyError(item.ingredient, (_d = item.unit) != null ? _d : "");
  }
  const grams = item.quantity * gramsPerUnit;
  const massResult = finalizeMetricMass(grams, roundMode);
  return {
    ...item,
    quantity: massResult.quantity,
    unit: massResult.unit,
    notes: `Converted using ${gramsPerUnit}g per ${normalizedUnit} for ${item.ingredient}.`
  };
}
function finalizeMetricVolume(milliliters, roundMode) {
  if (roundMode === "none") {
    return milliliters >= 1e3 ? { quantity: milliliters / 1e3, unit: "l" } : { quantity: milliliters, unit: "ml" };
  }
  const roundedMl = roundMilliliters(milliliters);
  if (roundedMl >= 1e3) {
    const liters = roundedMl / 1e3;
    return {
      quantity: roundLargeMetric(liters),
      unit: "l"
    };
  }
  return { quantity: roundedMl, unit: "ml" };
}
function finalizeMetricMass(grams, roundMode) {
  if (roundMode === "none") {
    return grams >= 1e3 ? { quantity: grams / 1e3, unit: "kg" } : { quantity: grams, unit: "g" };
  }
  const roundedGrams = roundGrams(grams);
  if (roundedGrams >= 1e3) {
    const kilograms = roundedGrams / 1e3;
    return {
      quantity: roundLargeMetric(kilograms),
      unit: "kg"
    };
  }
  return { quantity: roundedGrams, unit: "g" };
}
function roundGrams(value) {
  if (value < 1e3) {
    return Math.round(value);
  }
  return Math.round(value / 5) * 5;
}
function roundMilliliters(value) {
  if (value < 1e3) {
    return Math.round(value);
  }
  return Math.round(value / 10) * 10;
}
function roundLargeMetric(value) {
  return Math.round(value * 100) / 100;
}
function lookupEquivalency(ingredient, unit) {
  var _a;
  const key = ingredient.trim().toLowerCase();
  return (_a = VOLUME_TO_MASS_EQUIV_G_PER_UNIT[key]) == null ? void 0 : _a[unit];
}

// src/mise-en-place/index.ts
function miseEnPlace(ingredients) {
  const list = Array.isArray(ingredients) ? ingredients : [];
  const prepGroups = /* @__PURE__ */ new Map();
  const stateGroups = /* @__PURE__ */ new Map();
  let measureTask;
  let otherTask;
  const ungrouped = [];
  for (const ingredient of list) {
    if (!ingredient || typeof ingredient !== "object") continue;
    const label = deriveIngredientLabel(ingredient);
    const quantity = normalizeQuantity(ingredient.quantity);
    const baseNotes = toDisplayString(ingredient.notes);
    const prepNotes = toDisplayString(ingredient.prep);
    const isOptional = typeof ingredient.optional === "boolean" ? ingredient.optional : void 0;
    const buildItem = (extraNotes) => {
      const item = {
        ingredient: label
      };
      if (quantity) {
        item.quantity = { ...quantity };
      }
      if (typeof isOptional === "boolean") {
        item.optional = isOptional;
      }
      const notes = combineNotes(extraNotes, baseNotes);
      if (notes) {
        item.notes = notes;
      }
      return item;
    };
    let addedToTask = false;
    let hasPrepGrouping = false;
    const prepActionKeys = extractNormalizedList(ingredient.prepActions);
    if (prepActionKeys.length > 0) {
      hasPrepGrouping = true;
      for (const actionKey of prepActionKeys) {
        const task = ensureGroup(prepGroups, actionKey, () => ({
          category: "prep",
          action: actionKey,
          items: []
        }));
        task.items.push(buildItem());
        addedToTask = true;
      }
    } else {
      const singleActionKey = normalizeKey(ingredient.prepAction);
      if (singleActionKey) {
        hasPrepGrouping = true;
        const task = ensureGroup(prepGroups, singleActionKey, () => ({
          category: "prep",
          action: singleActionKey,
          items: []
        }));
        task.items.push(buildItem());
        addedToTask = true;
      } else if (prepNotes) {
        otherTask = otherTask != null ? otherTask : { category: "other", items: [] };
        otherTask.items.push(buildItem(prepNotes));
        addedToTask = true;
      }
    }
    const formKey = normalizeKey(ingredient.form);
    const hasStateGrouping = Boolean(formKey);
    if (formKey) {
      const task = ensureGroup(stateGroups, formKey, () => ({
        category: "state",
        form: formKey,
        items: []
      }));
      task.items.push(buildItem());
      addedToTask = true;
    }
    const shouldMeasure = Boolean(quantity) && !hasPrepGrouping && !hasStateGrouping;
    if (shouldMeasure) {
      measureTask = measureTask != null ? measureTask : { category: "measure", items: [] };
      measureTask.items.push(buildItem());
      addedToTask = true;
    }
    if (!addedToTask) {
      ungrouped.push(ingredient);
    }
  }
  const tasks = [
    ...Array.from(prepGroups.values()).sort((a, b) => localeCompare(a.action, b.action)),
    ...Array.from(stateGroups.values()).sort((a, b) => localeCompare(a.form, b.form))
  ];
  if (measureTask) {
    tasks.push(measureTask);
  }
  if (otherTask) {
    tasks.push(otherTask);
  }
  return { tasks, ungrouped };
}
function deriveIngredientLabel(ingredient) {
  var _a, _b, _c;
  return (_c = (_b = (_a = toDisplayString(ingredient.name)) != null ? _a : toDisplayString(ingredient.item)) != null ? _b : toDisplayString(ingredient.id)) != null ? _c : "ingredient";
}
function extractNormalizedList(values) {
  if (!Array.isArray(values)) {
    return [];
  }
  const seen = /* @__PURE__ */ new Set();
  const result = [];
  for (const value of values) {
    const key = normalizeKey(value);
    if (key && !seen.has(key)) {
      seen.add(key);
      result.push(key);
    }
  }
  return result;
}
function normalizeKey(value) {
  if (typeof value !== "string") {
    return null;
  }
  const trimmed = value.trim().toLowerCase();
  return trimmed || null;
}
function toDisplayString(value) {
  if (typeof value !== "string") {
    return void 0;
  }
  const trimmed = value.trim();
  return trimmed || void 0;
}
function combineNotes(...notes) {
  const cleaned = notes.map((note) => toDisplayString(note != null ? note : void 0)).filter(Boolean);
  if (cleaned.length === 0) {
    return void 0;
  }
  return cleaned.join(" | ");
}
function normalizeQuantity(quantity) {
  if (!quantity || typeof quantity !== "object") {
    return void 0;
  }
  const amount = quantity.amount;
  if (typeof amount !== "number" || Number.isNaN(amount)) {
    return void 0;
  }
  const normalized = { amount };
  if ("unit" in quantity) {
    const unit = quantity.unit;
    if (typeof unit === "string") {
      const trimmed = unit.trim();
      if (trimmed) {
        normalized.unit = trimmed;
      }
    } else if (unit === null) {
      normalized.unit = null;
    }
  }
  return normalized;
}
function ensureGroup(map, key, factory) {
  let task = map.get(key);
  if (!task) {
    task = factory();
    map.set(key, task);
  }
  return task;
}
function localeCompare(left, right) {
  return (left != null ? left : "").localeCompare(right != null ? right : "");
}

exports.MissingEquivalencyError = MissingEquivalencyError;
exports.SOUSTACK_SPEC_VERSION = SOUSTACK_SPEC_VERSION;
exports.UnknownUnitError = UnknownUnitError;
exports.UnsupportedConversionError = UnsupportedConversionError;
exports.convertLineItemToMetric = convertLineItemToMetric;
exports.detectProfiles = detectProfiles;
exports.extractSchemaOrgRecipeFromHTML = extractSchemaOrgRecipeFromHTML;
exports.fromSchemaOrg = fromSchemaOrg;
exports.miseEnPlace = miseEnPlace;
exports.normalizeRecipe = normalizeRecipe;
exports.scaleRecipe = scaleRecipe;
exports.toSchemaOrg = toSchemaOrg;
exports.validateRecipe = validateRecipe;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map