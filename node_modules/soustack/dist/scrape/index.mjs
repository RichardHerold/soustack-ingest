import { load } from 'cheerio';

// src/converters/yield.ts
function parseYield(value) {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (typeof value === "number") {
    return {
      amount: value,
      unit: "servings"
    };
  }
  if (Array.isArray(value)) {
    return parseYield(value[0]);
  }
  if (typeof value === "object") {
    const maybeYield = value;
    if (typeof maybeYield.amount === "number") {
      return {
        amount: maybeYield.amount,
        unit: typeof maybeYield.unit === "string" ? maybeYield.unit : "servings",
        description: typeof maybeYield.description === "string" ? maybeYield.description : void 0
      };
    }
  }
  if (typeof value === "string") {
    const trimmed = value.trim();
    const match = trimmed.match(/(\d+(?:\.\d+)?)/);
    if (match) {
      const amount = parseFloat(match[1]);
      const unit = trimmed.slice(match.index + match[1].length).trim();
      return {
        amount,
        unit: unit || "servings",
        description: trimmed
      };
    }
  }
  return void 0;
}

// src/parsers/duration.ts
var ISO_DURATION_REGEX = /^P(?:(\d+(?:\.\d+)?)D)?(?:T(?:(\d+(?:\.\d+)?)H)?(?:(\d+(?:\.\d+)?)M)?(?:(\d+(?:\.\d+)?)S)?)?$/i;
var HUMAN_OVERNIGHT = 8 * 60;
function parseDuration(iso) {
  if (typeof iso === "number" && Number.isFinite(iso)) {
    return iso;
  }
  if (!iso || typeof iso !== "string") return null;
  const trimmed = iso.trim();
  if (!trimmed) return null;
  const match = trimmed.match(ISO_DURATION_REGEX);
  if (!match) return null;
  const [, daysRaw, hoursRaw, minutesRaw, secondsRaw] = match;
  if (!daysRaw && !hoursRaw && !minutesRaw && !secondsRaw) {
    return null;
  }
  let total = 0;
  if (daysRaw) total += parseFloat(daysRaw) * 24 * 60;
  if (hoursRaw) total += parseFloat(hoursRaw) * 60;
  if (minutesRaw) total += parseFloat(minutesRaw);
  if (secondsRaw) total += Math.ceil(parseFloat(secondsRaw) / 60);
  return Math.round(total);
}
function parseHumanDuration(text) {
  if (!text || typeof text !== "string") return null;
  const normalized = text.toLowerCase().trim();
  if (!normalized) return null;
  if (normalized === "overnight") {
    return HUMAN_OVERNIGHT;
  }
  let total = 0;
  const hourRegex = /(\d+(?:\.\d+)?)\s*(?:hours?|hrs?|hr|h)\b/g;
  let hourMatch;
  while ((hourMatch = hourRegex.exec(normalized)) !== null) {
    total += parseFloat(hourMatch[1]) * 60;
  }
  const minuteRegex = /(\d+(?:\.\d+)?)\s*(?:minutes?|mins?|min|m)\b/g;
  let minuteMatch;
  while ((minuteMatch = minuteRegex.exec(normalized)) !== null) {
    total += parseFloat(minuteMatch[1]);
  }
  if (total <= 0) {
    return null;
  }
  return Math.round(total);
}
function smartParseDuration(input) {
  const iso = parseDuration(input);
  if (iso !== null) {
    return iso;
  }
  return parseHumanDuration(input);
}

// src/utils/image.ts
function normalizeImage(image) {
  if (!image) {
    return void 0;
  }
  if (typeof image === "string") {
    const trimmed = image.trim();
    return trimmed || void 0;
  }
  if (Array.isArray(image)) {
    const urls = image.map((entry) => typeof entry === "string" ? entry.trim() : extractUrl(entry)).filter((url) => typeof url === "string" && Boolean(url));
    if (urls.length === 0) {
      return void 0;
    }
    if (urls.length === 1) {
      return urls[0];
    }
    return urls;
  }
  return extractUrl(image);
}
function extractUrl(value) {
  if (!value || typeof value !== "object") {
    return void 0;
  }
  const record = value;
  const candidate = typeof record.url === "string" ? record.url : typeof record.contentUrl === "string" ? record.contentUrl : void 0;
  if (!candidate) {
    return void 0;
  }
  const trimmed = candidate.trim();
  return trimmed || void 0;
}

// src/normalize.ts
function normalizeRecipe(input) {
  if (!input || typeof input !== "object") {
    throw new Error("Recipe input must be an object");
  }
  const recipe = JSON.parse(JSON.stringify(input));
  const warnings = [];
  const legacyField = ["mod", "ules"].join("");
  if (legacyField in recipe) {
    throw new Error("The legacy field is no longer supported. Use `stacks` instead.");
  }
  normalizeStacks(recipe, warnings);
  if (!recipe.stacks) {
    recipe.stacks = {};
  }
  if (recipe && typeof recipe === "object" && "version" in recipe && !recipe.recipeVersion && typeof recipe.version === "string") {
    recipe.recipeVersion = recipe.version;
    warnings.push("'version' is deprecated; mapped to 'recipeVersion'.");
  }
  normalizeTime(recipe);
  return {
    recipe,
    warnings
  };
}
function normalizeStacks(recipe, warnings) {
  let stacks = {};
  if (recipe.stacks && typeof recipe.stacks === "object" && !Array.isArray(recipe.stacks)) {
    for (const [key, value] of Object.entries(recipe.stacks)) {
      if (typeof value === "number" && Number.isInteger(value) && value >= 1) {
        stacks[key] = value;
      } else {
        warnings.push(`Invalid stack version for '${key}': expected positive integer, got ${value}`);
      }
    }
  }
  if (Array.isArray(recipe.stacks)) {
    const stackIdentifiers = recipe.stacks.filter((s) => typeof s === "string");
    for (const identifier of stackIdentifiers) {
      const parsed = parseStackIdentifier(identifier);
      if (parsed) {
        const { name, version } = parsed;
        if (!stacks[name] || stacks[name] < version) {
          stacks[name] = version;
        }
      } else {
        warnings.push(`Invalid stack identifier '${identifier}': expected format 'name@version' (e.g., 'scaling@1')`);
      }
    }
  }
  recipe.stacks = stacks;
}
function parseStackIdentifier(identifier) {
  if (typeof identifier !== "string" || !identifier.trim()) {
    return null;
  }
  const match = identifier.trim().match(/^([a-z0-9_-]+)@(\d+)$/i);
  if (!match) {
    return null;
  }
  const [, name, versionStr] = match;
  const version = parseInt(versionStr, 10);
  if (isNaN(version) || version < 1) {
    return null;
  }
  return { name, version };
}
function normalizeTime(recipe) {
  const time = recipe?.time;
  if (!time || typeof time !== "object" || Array.isArray(time)) return;
  const structuredKeys = [
    "prep",
    "active",
    "passive",
    "total"
  ];
  structuredKeys.forEach((key) => {
    const value = time[key];
    if (typeof value === "number") return;
    const parsed = parseDuration(value);
    if (parsed !== null) {
      time[key] = parsed;
    }
  });
}

// src/fromSchemaOrg.ts
function fromSchemaOrg(input) {
  const recipeNode = extractRecipeNode(input);
  if (!recipeNode) {
    return null;
  }
  const ingredients = convertIngredients(recipeNode.recipeIngredient);
  const instructions = convertInstructions(recipeNode.recipeInstructions);
  const time = convertTime(recipeNode);
  const recipeYield = parseYield(recipeNode.recipeYield);
  const tags = collectTags(recipeNode.recipeCuisine, recipeNode.keywords);
  const category = extractFirst(recipeNode.recipeCategory);
  const source = convertSource(recipeNode);
  const dateModified = recipeNode.dateModified || void 0;
  const nutrition = convertNutrition(recipeNode.nutrition);
  const attribution = convertAttribution(recipeNode);
  const taxonomy = convertTaxonomy(tags, category, extractFirst(recipeNode.recipeCuisine));
  const media = convertMedia(recipeNode.image, recipeNode.video);
  const times = convertTimes(time);
  const stacks = {};
  if (attribution) stacks.attribution = 1;
  if (taxonomy) stacks.taxonomy = 1;
  if (media) stacks.media = 1;
  if (nutrition) stacks.nutrition = 1;
  if (times) stacks.times = 1;
  const rawRecipe = {
    "@type": "Recipe",
    profile: "minimal",
    stacks,
    name: recipeNode.name.trim(),
    description: recipeNode.description?.trim() || void 0,
    image: normalizeImage(recipeNode.image),
    category,
    tags: tags.length ? tags : void 0,
    source,
    dateAdded: recipeNode.datePublished || void 0,
    yield: recipeYield,
    time,
    ingredients,
    instructions,
    ...dateModified ? { dateModified } : {},
    ...nutrition ? { nutrition } : {},
    ...attribution ? { attribution } : {},
    ...taxonomy ? { taxonomy } : {},
    ...media ? { media } : {},
    ...times ? { times } : {}
  };
  const { recipe } = normalizeRecipe(rawRecipe);
  return recipe;
}
function extractRecipeNode(input) {
  if (!input) return null;
  if (Array.isArray(input)) {
    for (const entry of input) {
      const found = extractRecipeNode(entry);
      if (found) {
        return found;
      }
    }
    return null;
  }
  if (typeof input !== "object") {
    return null;
  }
  const record = input;
  if (record["@graph"]) {
    const fromGraph = extractRecipeNode(record["@graph"]);
    if (fromGraph) {
      return fromGraph;
    }
  }
  if (!hasRecipeType(record["@type"])) {
    return null;
  }
  if (!isValidName(record.name)) {
    return null;
  }
  return record;
}
function hasRecipeType(value) {
  if (!value) return false;
  const types = Array.isArray(value) ? value : [value];
  return types.some(
    (entry) => typeof entry === "string" && entry.toLowerCase() === "recipe"
  );
}
function isValidName(name) {
  return typeof name === "string" && Boolean(name.trim());
}
function convertIngredients(value) {
  if (!value) return [];
  const normalized = Array.isArray(value) ? value : [value];
  return normalized.map((item) => typeof item === "string" ? item.trim() : "").filter(Boolean);
}
function convertInstructions(value) {
  if (!value) return [];
  const normalized = Array.isArray(value) ? value : [value];
  const result = [];
  for (const entry of normalized) {
    if (!entry) continue;
    if (typeof entry === "string") {
      const text = entry.trim();
      if (text) {
        result.push(text);
      }
      continue;
    }
    if (isHowToSection(entry)) {
      const subsectionItems = extractSectionItems(entry.itemListElement);
      if (subsectionItems.length) {
        result.push({
          subsection: entry.name?.trim() || "Section",
          items: subsectionItems
        });
      }
      continue;
    }
    if (isHowToStep(entry)) {
      const parsed = convertHowToStep(entry);
      if (parsed) {
        result.push(parsed);
      }
    }
  }
  return result;
}
function extractSectionItems(items = []) {
  const result = [];
  for (const item of items) {
    if (!item) continue;
    if (typeof item === "string") {
      const text = item.trim();
      if (text) {
        result.push(text);
      }
      continue;
    }
    if (isHowToStep(item)) {
      const parsed = convertHowToStep(item);
      if (parsed) {
        result.push(parsed);
      }
      continue;
    }
    if (isHowToSection(item)) {
      result.push(...extractSectionItems(item.itemListElement));
    }
  }
  return result;
}
function extractInstructionText(value) {
  const text = typeof value.text === "string" ? value.text : value.name;
  return typeof text === "string" ? text.trim() || void 0 : void 0;
}
function convertHowToStep(step) {
  const text = extractInstructionText(step);
  if (!text) {
    return void 0;
  }
  const normalizedImage = normalizeImage(step.image);
  const image = Array.isArray(normalizedImage) ? normalizedImage[0] : normalizedImage;
  const id = extractInstructionId(step);
  const timing = extractInstructionTiming(step);
  if (!image && !id && !timing) {
    return text;
  }
  const instruction = { text };
  if (id) instruction.id = id;
  if (image) instruction.image = image;
  if (timing) instruction.timing = timing;
  return instruction;
}
function extractInstructionTiming(step) {
  const duration = step.totalTime || step.performTime || step.prepTime || step.duration;
  if (!duration || typeof duration !== "string") {
    return void 0;
  }
  const parsed = smartParseDuration(duration);
  return { duration: parsed ?? duration, type: "active" };
}
function extractInstructionId(step) {
  const raw = step["@id"] || step.id || step.url;
  if (typeof raw !== "string") {
    return void 0;
  }
  const trimmed = raw.trim();
  return trimmed || void 0;
}
function isHowToStep(value) {
  return Boolean(value) && typeof value === "object" && value["@type"] === "HowToStep";
}
function isHowToSection(value) {
  return Boolean(value) && typeof value === "object" && value["@type"] === "HowToSection" && Array.isArray(value.itemListElement);
}
function convertTime(recipe) {
  const prep = smartParseDuration(recipe.prepTime ?? "");
  const cook = smartParseDuration(recipe.cookTime ?? "");
  const total = smartParseDuration(recipe.totalTime ?? "");
  const structured = {};
  if (prep !== null && prep !== void 0) structured.prep = prep;
  if (cook !== null && cook !== void 0) structured.active = cook;
  if (total !== null && total !== void 0) structured.total = total;
  return Object.keys(structured).length ? structured : void 0;
}
function collectTags(cuisine, keywords) {
  const tags = /* @__PURE__ */ new Set();
  flattenStrings(cuisine).forEach((tag) => tags.add(tag));
  if (typeof keywords === "string") {
    splitKeywords(keywords).forEach((tag) => tags.add(tag));
  } else {
    flattenStrings(keywords).forEach((tag) => tags.add(tag));
  }
  return Array.from(tags);
}
function splitKeywords(value) {
  return value.split(/[,|]/).map((part) => part.trim()).filter(Boolean);
}
function flattenStrings(value) {
  if (!value) return [];
  if (typeof value === "string") return [value.trim()].filter(Boolean);
  if (Array.isArray(value)) {
    return value.map((item) => typeof item === "string" ? item.trim() : "").filter(Boolean);
  }
  return [];
}
function extractFirst(value) {
  const arr = flattenStrings(value);
  return arr.length ? arr[0] : void 0;
}
function convertSource(recipe) {
  const author = extractEntityName(recipe.author);
  const publisher = extractEntityName(recipe.publisher);
  const url = (recipe.url || recipe.mainEntityOfPage)?.trim();
  const source = {};
  if (author) source.author = author;
  if (publisher) source.name = publisher;
  if (url) source.url = url;
  return Object.keys(source).length ? source : void 0;
}
function extractEntityName(value) {
  if (!value) return void 0;
  if (typeof value === "string") {
    const trimmed = value.trim();
    return trimmed || void 0;
  }
  if (Array.isArray(value)) {
    for (const entry of value) {
      const name = extractEntityName(entry);
      if (name) {
        return name;
      }
    }
    return void 0;
  }
  if (typeof value === "object" && typeof value.name === "string") {
    const trimmed = value.name.trim();
    return trimmed || void 0;
  }
  return void 0;
}
function convertAttribution(recipe) {
  const attribution = {};
  const url = (recipe.url || recipe.mainEntityOfPage)?.trim();
  const author = extractEntityName(recipe.author);
  const datePublished = recipe.datePublished?.trim();
  if (url) attribution.url = url;
  if (author) attribution.author = author;
  if (datePublished) attribution.datePublished = datePublished;
  return Object.keys(attribution).length ? attribution : void 0;
}
function convertTaxonomy(keywords, category, cuisine) {
  const taxonomy = {};
  if (keywords.length) taxonomy.keywords = keywords;
  if (category) taxonomy.category = category;
  if (cuisine) taxonomy.cuisine = cuisine;
  return Object.keys(taxonomy).length ? taxonomy : void 0;
}
function normalizeMediaList(value) {
  if (!value) return [];
  if (typeof value === "string") return [value.trim()].filter(Boolean);
  if (Array.isArray(value)) {
    return value.map((item) => typeof item === "string" ? item.trim() : extractMediaUrl(item)).filter((entry) => Boolean(entry?.length));
  }
  const url = extractMediaUrl(value);
  return url ? [url] : [];
}
function extractMediaUrl(value) {
  if (value && typeof value === "object" && "url" in value && typeof value.url === "string") {
    const trimmed = value.url.trim();
    return trimmed || void 0;
  }
  return void 0;
}
function convertMedia(image, video) {
  const normalizedImage = normalizeImage(image);
  const images = normalizedImage ? Array.isArray(normalizedImage) ? normalizedImage : [normalizedImage] : [];
  const videos = normalizeMediaList(video);
  const media = {};
  if (images.length) media.images = images;
  if (videos.length) media.videos = videos;
  return Object.keys(media).length ? media : void 0;
}
function convertTimes(time) {
  if (!time) return void 0;
  const times = {};
  if (typeof time.prep === "number") times.prepMinutes = time.prep;
  if (typeof time.active === "number") times.cookMinutes = time.active;
  if (typeof time.total === "number") times.totalMinutes = time.total;
  return Object.keys(times).length ? times : void 0;
}
function convertNutrition(nutrition) {
  if (!nutrition || typeof nutrition !== "object") {
    return void 0;
  }
  const result = {};
  let hasData = false;
  if ("calories" in nutrition) {
    const calories = nutrition.calories;
    if (typeof calories === "number") {
      result.calories = calories;
      hasData = true;
    } else if (typeof calories === "string") {
      const parsed = parseFloat(calories.replace(/[^\d.-]/g, ""));
      if (!isNaN(parsed)) {
        result.calories = parsed;
        hasData = true;
      }
    }
  }
  if ("proteinContent" in nutrition || "protein_g" in nutrition) {
    const protein = nutrition.proteinContent || nutrition.protein_g;
    if (typeof protein === "number") {
      result.protein_g = protein;
      hasData = true;
    } else if (typeof protein === "string") {
      const parsed = parseFloat(protein.replace(/[^\d.-]/g, ""));
      if (!isNaN(parsed)) {
        result.protein_g = parsed;
        hasData = true;
      }
    }
  }
  return hasData ? result : void 0;
}

// src/scraper/fetch.ts
var DEFAULT_USER_AGENTS = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0"
];
function chooseUserAgent(provided) {
  if (provided) return provided;
  const index = Math.floor(Math.random() * DEFAULT_USER_AGENTS.length);
  return DEFAULT_USER_AGENTS[index];
}
function resolveFetch(fetchFn) {
  if (fetchFn) {
    return fetchFn;
  }
  const globalFetch = globalThis.fetch;
  if (!globalFetch) {
    throw new Error(
      "A global fetch implementation is not available. Provide window.fetch in browsers or upgrade to Node 18+."
    );
  }
  return globalFetch;
}
function isBrowserEnvironment() {
  return typeof globalThis.document !== "undefined";
}
function isClientError(error) {
  if (typeof error.status === "number") {
    return error.status >= 400 && error.status < 500;
  }
  return error.message.includes("HTTP 4");
}
async function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function fetchPage(url, options = {}) {
  const {
    timeout = 1e4,
    userAgent,
    maxRetries = 2,
    fetchFn
  } = options;
  let lastError = null;
  const resolvedFetch = resolveFetch(fetchFn);
  const isBrowser2 = isBrowserEnvironment();
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    try {
      const headers = {
        Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5"
      };
      if (!isBrowser2) {
        headers["User-Agent"] = chooseUserAgent(userAgent);
      }
      const requestInit = {
        headers,
        signal: controller.signal,
        redirect: "follow"
      };
      const response = await resolvedFetch(url, requestInit);
      clearTimeout(timeoutId);
      if (response && typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
        const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
        if (ingestUrl) {
          try {
            const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
            if (globalFetch) {
              globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/fetch.ts:63", message: "fetch response", data: { url, status: response.status, statusText: response.statusText, ok: response.ok, isNYTimes: url.includes("nytimes.com") }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "B" }) }).catch(() => {
              });
            }
          } catch {
          }
        }
      }
      if (!response.ok) {
        const error = new Error(
          `HTTP ${response.status}: ${response.statusText}`
        );
        error.status = response.status;
        throw error;
      }
      const html = await response.text();
      if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
        const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
        if (ingestUrl) {
          try {
            const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
            if (globalFetch) {
              globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/fetch.ts:75", message: "HTML received", data: { htmlLength: html.length, hasLoginPage: html.toLowerCase().includes("login") || html.toLowerCase().includes("sign in"), hasRecipeData: html.includes("application/ld+json") || html.includes("schema.org/Recipe") }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "B,D" }) }).catch(() => {
              });
            }
          } catch {
          }
        }
      }
      return html;
    } catch (err) {
      clearTimeout(timeoutId);
      lastError = err instanceof Error ? err : new Error(String(err));
      if (isClientError(lastError)) {
        throw lastError;
      }
      if (attempt < maxRetries) {
        await wait(1e3 * (attempt + 1));
        continue;
      }
    }
  }
  throw lastError ?? new Error("Failed to fetch page");
}

// src/scraper/extractors/utils.ts
var RECIPE_TYPES = /* @__PURE__ */ new Set([
  "recipe",
  "https://schema.org/recipe",
  "http://schema.org/recipe"
]);
function isRecipeNode(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const type = value["@type"];
  if (typeof type === "string") {
    return RECIPE_TYPES.has(type.toLowerCase());
  }
  if (Array.isArray(type)) {
    return type.some(
      (entry) => typeof entry === "string" && RECIPE_TYPES.has(entry.toLowerCase())
    );
  }
  return false;
}
function safeJsonParse(content) {
  try {
    return JSON.parse(content);
  } catch {
    return null;
  }
}
function normalizeText(value) {
  if (!value) return void 0;
  const trimmed = value.replace(/\s+/g, " ").trim();
  return trimmed || void 0;
}

// src/scraper/extractors/jsonld.ts
function extractJsonLd(html) {
  const $ = load(html);
  const scripts = $('script[type="application/ld+json"]');
  const candidates = [];
  scripts.each((_, element) => {
    const content = $(element).html();
    if (!content) return;
    const parsed = safeJsonParse(content);
    if (!parsed) return;
    collectCandidates(parsed, candidates);
  });
  return candidates[0] ?? null;
}
function collectCandidates(payload, bucket) {
  if (!payload) return;
  if (Array.isArray(payload)) {
    payload.forEach((entry) => collectCandidates(entry, bucket));
    return;
  }
  if (typeof payload !== "object") {
    return;
  }
  if (isRecipeNode(payload)) {
    bucket.push(payload);
    return;
  }
  const graph = payload["@graph"];
  if (Array.isArray(graph)) {
    graph.forEach((entry) => collectCandidates(entry, bucket));
  }
}
var SIMPLE_PROPS = [
  "name",
  "description",
  "image",
  "recipeYield",
  "prepTime",
  "cookTime",
  "totalTime"
];
function extractMicrodata(html) {
  const $ = load(html);
  const recipeEl = $('[itemscope][itemtype*="schema.org/Recipe"]').first();
  if (!recipeEl.length) {
    return null;
  }
  const recipe = {
    "@type": "Recipe"
  };
  SIMPLE_PROPS.forEach((prop) => {
    const value = findPropertyValue($, recipeEl, prop);
    if (value) {
      recipe[prop] = value;
    }
  });
  const ingredients = [];
  recipeEl.find('[itemprop="recipeIngredient"]').each((_, el) => {
    const text = normalizeText($(el).attr("content") || $(el).text());
    if (text) ingredients.push(text);
  });
  if (ingredients.length) {
    recipe.recipeIngredient = ingredients;
  }
  const instructions = [];
  recipeEl.find('[itemprop="recipeInstructions"]').each((_, el) => {
    const text = normalizeText($(el).attr("content")) || normalizeText($(el).find('[itemprop="text"]').first().text()) || normalizeText($(el).text());
    if (text) instructions.push(text);
  });
  if (instructions.length) {
    recipe.recipeInstructions = instructions;
  }
  if (recipe.name || ingredients.length) {
    return recipe;
  }
  return null;
}
function findPropertyValue($, context, prop) {
  const node = context.find(`[itemprop="${prop}"]`).first();
  if (!node.length) return void 0;
  return normalizeText(node.attr("content")) || normalizeText(node.attr("href")) || normalizeText(node.attr("src")) || normalizeText(node.text());
}

// src/scraper/extractors/browser.ts
var SIMPLE_PROPS2 = ["name", "description", "image", "recipeYield", "prepTime", "cookTime", "totalTime"];
function extractRecipeBrowser(html) {
  const jsonLdRecipe = extractJsonLdBrowser(html);
  if (jsonLdRecipe) {
    return { recipe: jsonLdRecipe, source: "jsonld" };
  }
  const microdataRecipe = extractMicrodataBrowser(html);
  if (microdataRecipe) {
    return { recipe: microdataRecipe, source: "microdata" };
  }
  return { recipe: null, source: null };
}
function extractJsonLdBrowser(html) {
  if (typeof globalThis.DOMParser === "undefined") {
    return null;
  }
  const parser = new globalThis.DOMParser();
  const doc = parser.parseFromString(html, "text/html");
  const scripts = doc.querySelectorAll('script[type="application/ld+json"]');
  const candidates = [];
  scripts.forEach((script) => {
    const content = script.textContent;
    if (!content) return;
    const parsed = safeJsonParse(content);
    if (!parsed) return;
    collectCandidates2(parsed, candidates);
  });
  return candidates[0] ?? null;
}
function extractMicrodataBrowser(html) {
  if (typeof globalThis.DOMParser === "undefined") {
    return null;
  }
  const parser = new globalThis.DOMParser();
  const doc = parser.parseFromString(html, "text/html");
  const recipeEl = doc.querySelector('[itemscope][itemtype*="schema.org/Recipe"]');
  if (!recipeEl) {
    return null;
  }
  const recipe = {
    "@type": "Recipe"
  };
  SIMPLE_PROPS2.forEach((prop) => {
    const value = findPropertyValue2(recipeEl, prop);
    if (value) {
      recipe[prop] = value;
    }
  });
  const ingredients = [];
  recipeEl.querySelectorAll('[itemprop="recipeIngredient"]').forEach((el) => {
    const text = normalizeText(
      el.getAttribute("content") || el.textContent || void 0
    );
    if (text) ingredients.push(text);
  });
  if (ingredients.length) {
    recipe.recipeIngredient = ingredients;
  }
  const instructions = [];
  recipeEl.querySelectorAll('[itemprop="recipeInstructions"]').forEach((el) => {
    const text = normalizeText(el.getAttribute("content")) || normalizeText(el.querySelector('[itemprop="text"]')?.textContent || void 0) || normalizeText(el.textContent || void 0);
    if (text) instructions.push(text);
  });
  if (instructions.length) {
    recipe.recipeInstructions = instructions;
  }
  if (recipe.name || ingredients.length) {
    return recipe;
  }
  return null;
}
function findPropertyValue2(context, prop) {
  const node = context.querySelector(`[itemprop="${prop}"]`);
  if (!node) return void 0;
  return normalizeText(node.getAttribute("content")) || normalizeText(node.getAttribute("href")) || normalizeText(node.getAttribute("src")) || normalizeText(node.textContent || void 0);
}
function collectCandidates2(payload, bucket) {
  if (!payload) return;
  if (Array.isArray(payload)) {
    payload.forEach((entry) => collectCandidates2(entry, bucket));
    return;
  }
  if (typeof payload !== "object") {
    return;
  }
  if (isRecipeNode(payload)) {
    bucket.push(payload);
    return;
  }
  const graph = payload["@graph"];
  if (Array.isArray(graph)) {
    graph.forEach((entry) => collectCandidates2(entry, bucket));
  }
}

// src/scraper/extractors/index.ts
function isBrowser() {
  try {
    return typeof globalThis.DOMParser !== "undefined";
  } catch {
    return false;
  }
}
function extractRecipe(html) {
  if (isBrowser()) {
    return extractRecipeBrowser(html);
  }
  const jsonLdRecipe = extractJsonLd(html);
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/extractors/index.ts:6", message: "JSON-LD extraction result", data: { hasJsonLd: !!jsonLdRecipe }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "C,D" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  if (jsonLdRecipe) {
    return { recipe: jsonLdRecipe, source: "jsonld" };
  }
  const microdataRecipe = extractMicrodata(html);
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/extractors/index.ts:12", message: "Microdata extraction result", data: { hasMicrodata: !!microdataRecipe }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "D" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  if (microdataRecipe) {
    return { recipe: microdataRecipe, source: "microdata" };
  }
  return { recipe: null, source: null };
}

// src/scraper/index.ts
async function scrapeRecipe(url, options = {}) {
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/index.ts:7", message: "scrapeRecipe entry", data: { url, hasOptions: !!options }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "A,B,C,D,E" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  const html = await fetchPage(url, options);
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/index.ts:9", message: "HTML fetched", data: { htmlLength: html?.length, htmlPreview: html?.substring(0, 200) }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "B" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  const { recipe } = extractRecipe(html);
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/index.ts:11", message: "extractRecipe result", data: { hasRecipe: !!recipe, recipeType: recipe?.["@type"], recipeName: recipe?.name }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "A,C,D" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  if (!recipe) {
    throw new Error("No Schema.org recipe data found in page");
  }
  const soustackRecipe = fromSchemaOrg(recipe);
  if (typeof process !== "undefined" && process.env.NODE_ENV !== "test") {
    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;
    if (ingestUrl) {
      try {
        const globalFetch = typeof globalThis !== "undefined" && typeof globalThis.fetch !== "undefined" ? globalThis.fetch : null;
        if (globalFetch) {
          globalFetch(ingestUrl, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ location: "scraper/index.ts:17", message: "fromSchemaOrg result", data: { hasSoustackRecipe: !!soustackRecipe, soustackRecipeName: soustackRecipe?.name }, timestamp: Date.now(), sessionId: "debug-session", runId: "run1", hypothesisId: "A" }) }).catch(() => {
          });
        }
      } catch {
      }
    }
  }
  if (!soustackRecipe) {
    throw new Error("Schema.org data did not include a valid recipe");
  }
  return soustackRecipe;
}
function extractRecipeFromHTML(html) {
  const { recipe } = extractRecipe(html);
  if (!recipe) {
    throw new Error("No Schema.org recipe data found in HTML");
  }
  const soustackRecipe = fromSchemaOrg(recipe);
  if (!soustackRecipe) {
    throw new Error("Schema.org data did not include a valid recipe");
  }
  return soustackRecipe;
}
function extractSchemaOrgRecipeFromHTML(html) {
  const { recipe } = extractRecipe(html);
  return recipe;
}

export { extractRecipeFromHTML, extractSchemaOrgRecipeFromHTML, fetchPage, scrapeRecipe };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map