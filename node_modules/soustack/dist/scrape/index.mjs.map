{"version":3,"sources":["../../src/converters/yield.ts","../../src/parsers/duration.ts","../../src/utils/image.ts","../../src/normalize.ts","../../src/fromSchemaOrg.ts","../../src/scraper/fetch.ts","../../src/scraper/extractors/utils.ts","../../src/scraper/extractors/jsonld.ts","../../src/scraper/extractors/microdata.ts","../../src/scraper/extractors/browser.ts","../../src/scraper/extractors/index.ts","../../src/scraper/index.ts"],"names":["isBrowser","load","SIMPLE_PROPS","collectCandidates","findPropertyValue"],"mappings":"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","file":"index.mjs","sourcesContent":["import { Yield } from '../types';\n\nexport function parseYield(value: unknown): Yield | undefined {\n  if (value === undefined || value === null) {\n    return undefined;\n  }\n\n  if (typeof value === 'number') {\n    return {\n      amount: value,\n      unit: 'servings'\n    };\n  }\n\n  if (Array.isArray(value)) {\n    return parseYield(value[0]);\n  }\n\n  if (typeof value === 'object') {\n    const maybeYield = value as Record<string, any>;\n    if (typeof maybeYield.amount === 'number') {\n      return {\n        amount: maybeYield.amount,\n        unit: typeof maybeYield.unit === 'string' ? maybeYield.unit : 'servings',\n        description:\n          typeof maybeYield.description === 'string'\n            ? maybeYield.description\n            : undefined\n      };\n    }\n  }\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    const match = trimmed.match(/(\\d+(?:\\.\\d+)?)/);\n    if (match) {\n      const amount = parseFloat(match[1]);\n      const unit = trimmed.slice(match.index! + match[1].length).trim();\n      return {\n        amount,\n        unit: unit || 'servings',\n        description: trimmed\n      };\n    }\n  }\n\n  return undefined;\n}\n\nexport function formatYield(yieldValue?: Yield): string | undefined {\n  if (!yieldValue) return undefined;\n  if (!yieldValue.amount && !yieldValue.unit) {\n    return undefined;\n  }\n\n  const amount = yieldValue.amount ?? '';\n  const unit = yieldValue.unit ? ` ${yieldValue.unit}` : '';\n  return `${amount}${unit}`.trim() || yieldValue.description;\n}\n","const ISO_DURATION_REGEX =\n  /^P(?:(\\d+(?:\\.\\d+)?)D)?(?:T(?:(\\d+(?:\\.\\d+)?)H)?(?:(\\d+(?:\\.\\d+)?)M)?(?:(\\d+(?:\\.\\d+)?)S)?)?$/i;\n\nconst HUMAN_OVERNIGHT = 8 * 60; // 8 hours\n\nfunction isFiniteNumber(value: unknown): value is number {\n  return typeof value === 'number' && Number.isFinite(value);\n}\n\nexport function parseDuration(iso: string | number): number | null;\nexport function parseDuration(iso: string | number | null | undefined): number | null;\nexport function parseDuration(iso: string | number | null | undefined): number | null {\n  if (typeof iso === 'number' && Number.isFinite(iso)) {\n    return iso;\n  }\n\n  if (!iso || typeof iso !== 'string') return null;\n\n  const trimmed = iso.trim();\n  if (!trimmed) return null;\n\n  const match = trimmed.match(ISO_DURATION_REGEX);\n  if (!match) return null;\n\n  const [, daysRaw, hoursRaw, minutesRaw, secondsRaw] = match;\n\n  if (!daysRaw && !hoursRaw && !minutesRaw && !secondsRaw) {\n    return null;\n  }\n\n  let total = 0;\n  if (daysRaw) total += parseFloat(daysRaw) * 24 * 60;\n  if (hoursRaw) total += parseFloat(hoursRaw) * 60;\n  if (minutesRaw) total += parseFloat(minutesRaw);\n  if (secondsRaw) total += Math.ceil(parseFloat(secondsRaw) / 60);\n\n  return Math.round(total);\n}\n\nexport function formatDuration(minutes: number): string;\nexport function formatDuration(minutes: number | null | undefined): string;\nexport function formatDuration(minutes: number | null | undefined): string {\n  if (!isFiniteNumber(minutes) || minutes <= 0) {\n    return 'PT0M';\n  }\n\n  const rounded = Math.round(minutes);\n  const days = Math.floor(rounded / (24 * 60));\n  const afterDays = rounded % (24 * 60);\n  const hours = Math.floor(afterDays / 60);\n  const mins = afterDays % 60;\n\n  let result = 'P';\n\n  if (days > 0) {\n    result += `${days}D`;\n  }\n\n  if (hours > 0 || mins > 0) {\n    result += 'T';\n    if (hours > 0) {\n      result += `${hours}H`;\n    }\n    if (mins > 0) {\n      result += `${mins}M`;\n    }\n  }\n\n  if (result === 'P') {\n    return 'PT0M';\n  }\n\n  return result;\n}\n\nexport function parseHumanDuration(text: string): number | null;\nexport function parseHumanDuration(text: string | null | undefined): number | null;\nexport function parseHumanDuration(text: string | null | undefined): number | null {\n  if (!text || typeof text !== 'string') return null;\n\n  const normalized = text.toLowerCase().trim();\n  if (!normalized) return null;\n\n  if (normalized === 'overnight') {\n    return HUMAN_OVERNIGHT;\n  }\n\n  let total = 0;\n\n  const hourRegex = /(\\d+(?:\\.\\d+)?)\\s*(?:hours?|hrs?|hr|h)\\b/g;\n  let hourMatch: RegExpExecArray | null;\n  while ((hourMatch = hourRegex.exec(normalized)) !== null) {\n    total += parseFloat(hourMatch[1]) * 60;\n  }\n\n  const minuteRegex = /(\\d+(?:\\.\\d+)?)\\s*(?:minutes?|mins?|min|m)\\b/g;\n  let minuteMatch: RegExpExecArray | null;\n  while ((minuteMatch = minuteRegex.exec(normalized)) !== null) {\n    total += parseFloat(minuteMatch[1]);\n  }\n\n  if (total <= 0) {\n    return null;\n  }\n\n  return Math.round(total);\n}\n\nexport function smartParseDuration(input: string): number | null;\nexport function smartParseDuration(input: string | null | undefined): number | null;\nexport function smartParseDuration(input: string | null | undefined): number | null {\n  const iso = parseDuration(input);\n  if (iso !== null) {\n    return iso;\n  }\n  return parseHumanDuration(input);\n}\n","import { SchemaOrgImage } from '../types/schemaOrg';\n\n/**\n * Normalize Schema.org image formats to Soustack format.\n * - String values pass through\n * - Arrays collapse to string or string[] after URL extraction\n * - ImageObjects extract their url/contentUrl\n */\nexport function normalizeImage(\n  image: SchemaOrgImage | undefined | null\n): string | string[] | undefined {\n  if (!image) {\n    return undefined;\n  }\n\n  if (typeof image === 'string') {\n    const trimmed = image.trim();\n    return trimmed || undefined;\n  }\n\n  if (Array.isArray(image)) {\n    const urls = image\n      .map(entry => (typeof entry === 'string' ? entry.trim() : extractUrl(entry)))\n      .filter((url): url is string => typeof url === 'string' && Boolean(url));\n\n    if (urls.length === 0) {\n      return undefined;\n    }\n    if (urls.length === 1) {\n      return urls[0];\n    }\n    return urls;\n  }\n\n  return extractUrl(image);\n}\n\nfunction extractUrl(\n  value: Exclude<SchemaOrgImage, string | string[] | undefined | null>\n): string | undefined {\n  if (!value || typeof value !== 'object') {\n    return undefined;\n  }\n\n  const record = value as { url?: unknown; contentUrl?: unknown };\n  const candidate =\n    typeof record.url === 'string'\n      ? record.url\n      : typeof record.contentUrl === 'string'\n        ? record.contentUrl\n        : undefined;\n\n  if (!candidate) {\n    return undefined;\n  }\n\n  const trimmed = candidate.trim();\n  return trimmed || undefined;\n}\n","import { parseDuration } from './parsers/duration';\nimport { Recipe } from './types';\n\nexport interface NormalizationResult {\n  recipe: Recipe;\n  warnings: string[];\n}\n\n/**\n * Normalizes a recipe input to the current spec format:\n * - Rejects inputs with legacy field (unsupported)\n * - Converts legacy `stacks` array format to map format\n * - Ensures `stacks` exists even if empty\n * - Preserves existing `stacks` map format\n * \n * @param input - Raw recipe input (may have legacy formats)\n * @returns Normalized recipe with warnings for any issues encountered\n * @throws Error if input contains legacy field\n */\nexport function normalizeRecipe(input: unknown): NormalizationResult {\n  if (!input || typeof input !== 'object') {\n    throw new Error('Recipe input must be an object');\n  }\n\n  const recipe = JSON.parse(JSON.stringify(input)) as any;\n  const warnings: string[] = [];\n\n  // Reject inputs with legacy field\n  const legacyField = [\"mod\", \"ules\"].join(\"\");\n  if (legacyField in recipe) {\n    throw new Error('The legacy field is no longer supported. Use `stacks` instead.');\n  }\n\n  // Normalize stacks from legacy array format\n  normalizeStacks(recipe, warnings);\n\n  // Ensure stacks exists (even if empty)\n  if (!recipe.stacks) {\n    recipe.stacks = {};\n  }\n\n  // Normalize deprecated version field\n  if (\n    recipe &&\n    typeof recipe === 'object' &&\n    'version' in recipe &&\n    !(recipe as any).recipeVersion &&\n    typeof (recipe as any).version === 'string'\n  ) {\n    (recipe as any).recipeVersion = (recipe as any).version;\n    warnings.push(\"'version' is deprecated; mapped to 'recipeVersion'.\");\n  }\n\n  // Normalize time\n  normalizeTime(recipe);\n\n  return {\n    recipe: recipe as Recipe,\n    warnings,\n  };\n}\n\n/**\n * Normalizes the stacks field from legacy formats to the map format.\n * Handles:\n * - Legacy `stacks` array: [\"scaling@1\"] -> { scaling: 1 }\n * - Existing `stacks` map: { scaling: 1 } -> preserved as-is\n */\nfunction normalizeStacks(recipe: any, warnings: string[]): void {\n  // Start with existing stacks map if valid\n  let stacks: Record<string, number> = {};\n  if (recipe.stacks && typeof recipe.stacks === 'object' && !Array.isArray(recipe.stacks)) {\n    // Validate that all values are numbers and copy valid entries\n    for (const [key, value] of Object.entries(recipe.stacks)) {\n      if (typeof value === 'number' && Number.isInteger(value) && value >= 1) {\n        stacks[key] = value;\n      } else {\n        warnings.push(`Invalid stack version for '${key}': expected positive integer, got ${value}`);\n      }\n    }\n  }\n\n  // Check legacy stacks array format (only if stacks wasn't already a map)\n  if (Array.isArray(recipe.stacks)) {\n    const stackIdentifiers: string[] = recipe.stacks.filter((s: any) => typeof s === 'string');\n\n    // Parse stack identifiers into stacks map and merge with existing stacks\n    for (const identifier of stackIdentifiers) {\n      const parsed = parseStackIdentifier(identifier);\n      if (parsed) {\n        const { name, version } = parsed;\n        // If the same stack appears multiple times, keep the highest version\n        if (!stacks[name] || stacks[name] < version) {\n          stacks[name] = version;\n        }\n      } else {\n        warnings.push(`Invalid stack identifier '${identifier}': expected format 'name@version' (e.g., 'scaling@1')`);\n      }\n    }\n  }\n\n  // Set the normalized stacks\n  recipe.stacks = stacks;\n}\n\n/**\n * Parses a stack identifier string like \"scaling@1\" into { name: \"scaling\", version: 1 }\n * Returns null if the format is invalid.\n */\nfunction parseStackIdentifier(identifier: string): { name: string; version: number } | null {\n  if (typeof identifier !== 'string' || !identifier.trim()) {\n    return null;\n  }\n\n  const match = identifier.trim().match(/^([a-z0-9_-]+)@(\\d+)$/i);\n  if (!match) {\n    return null;\n  }\n\n  const [, name, versionStr] = match;\n  const version = parseInt(versionStr, 10);\n\n  if (isNaN(version) || version < 1) {\n    return null;\n  }\n\n  return { name, version };\n}\n\nfunction normalizeTime(recipe: Recipe): void {\n  const time = (recipe as any)?.time;\n  if (!time || typeof time !== 'object' || Array.isArray(time)) return;\n\n  const structuredKeys: Array<'prep' | 'active' | 'passive' | 'total'> = [\n    'prep',\n    'active',\n    'passive',\n    'total',\n  ];\n\n  structuredKeys.forEach((key) => {\n    const value = (time as any)[key];\n    if (typeof value === 'number') return;\n\n    const parsed = parseDuration(value as any);\n    if (parsed !== null) {\n      (time as any)[key] = parsed;\n    }\n  });\n}\n","import {\n  IngredientItem,\n  Instruction,\n  InstructionItem,\n  Recipe,\n  Source,\n  AttributionModule,\n  TaxonomyModule,\n  MediaModule,\n  TimesModule,\n  NutritionFacts,\n  StepTiming,\n  StructuredTime\n} from './types';\nimport { parseYield } from './converters/yield';\nimport { smartParseDuration } from './parsers/duration';\nimport {\n  HowToSection,\n  HowToStep,\n  SchemaOrgPersonOrOrganization,\n  SchemaOrgRecipe,\n  SchemaOrgImage\n} from './types/schemaOrg';\nimport { normalizeImage } from './utils/image';\nimport { normalizeRecipe } from './normalize';\n\nexport function fromSchemaOrg(input: unknown): Recipe | null {\n  const recipeNode = extractRecipeNode(input);\n  if (!recipeNode) {\n    return null;\n  }\n\n  const ingredients = convertIngredients(recipeNode.recipeIngredient);\n  const instructions = convertInstructions(recipeNode.recipeInstructions);\n  const time = convertTime(recipeNode);\n  const recipeYield = parseYield(recipeNode.recipeYield);\n  const tags = collectTags(recipeNode.recipeCuisine, recipeNode.keywords);\n  const category = extractFirst(recipeNode.recipeCategory);\n  const source = convertSource(recipeNode);\n  const dateModified = recipeNode.dateModified || undefined;\n  const nutrition = convertNutrition(recipeNode.nutrition);\n\n  const attribution = convertAttribution(recipeNode);\n  const taxonomy = convertTaxonomy(tags, category, extractFirst(recipeNode.recipeCuisine));\n  const media = convertMedia(recipeNode.image, recipeNode.video);\n  const times = convertTimes(time);\n\n  // Build stacks map from payloads\n  const stacks: Record<string, number> = {};\n  if (attribution) stacks.attribution = 1;\n  if (taxonomy) stacks.taxonomy = 1;\n  if (media) stacks.media = 1;\n  if (nutrition) stacks.nutrition = 1;\n  if (times) stacks.times = 1;\n\n  const rawRecipe = {\n    '@type': 'Recipe',\n    profile: 'minimal',\n    stacks,\n    name: recipeNode.name.trim(),\n    description: recipeNode.description?.trim() || undefined,\n    image: normalizeImage(recipeNode.image),\n    category,\n    tags: tags.length ? tags : undefined,\n    source,\n    dateAdded: recipeNode.datePublished || undefined,\n    yield: recipeYield,\n    time,\n    ingredients,\n    instructions,\n    ...(dateModified ? { dateModified } : {}),\n    ...(nutrition ? { nutrition } : {}),\n    ...(attribution ? { attribution } : {}),\n    ...(taxonomy ? { taxonomy } : {}),\n    ...(media ? { media } : {}),\n    ...(times ? { times } : {})\n  };\n\n  // Normalize the recipe to ensure it's in the correct format\n  const { recipe } = normalizeRecipe(rawRecipe);\n  \n  return recipe;\n}\n\nfunction extractRecipeNode(input: unknown): SchemaOrgRecipe | null {\n  if (!input) return null;\n\n  if (Array.isArray(input)) {\n    for (const entry of input) {\n      const found = extractRecipeNode(entry);\n      if (found) {\n        return found;\n      }\n    }\n    return null;\n  }\n\n  if (typeof input !== 'object') {\n    return null;\n  }\n\n  const record = input as Partial<SchemaOrgRecipe> & { [key: string]: unknown };\n\n  if (record['@graph']) {\n    const fromGraph = extractRecipeNode(record['@graph']);\n    if (fromGraph) {\n      return fromGraph;\n    }\n  }\n\n  if (!hasRecipeType(record['@type'])) {\n    return null;\n  }\n\n  if (!isValidName(record.name)) {\n    return null;\n  }\n\n  return record as SchemaOrgRecipe;\n}\n\nfunction hasRecipeType(value: SchemaOrgRecipe['@type']): boolean {\n  if (!value) return false;\n  const types = Array.isArray(value) ? value : [value];\n  return types.some(\n    entry => typeof entry === 'string' && entry.toLowerCase() === 'recipe'\n  );\n}\n\nfunction isValidName(name: unknown): name is string {\n  return typeof name === 'string' && Boolean(name.trim());\n}\n\nfunction convertIngredients(\n  value: SchemaOrgRecipe['recipeIngredient']\n): IngredientItem[] {\n  if (!value) return [];\n  const normalized = Array.isArray(value) ? value : [value];\n  return normalized\n    .map(item => (typeof item === 'string' ? item.trim() : ''))\n    .filter(Boolean);\n}\n\nfunction convertInstructions(\n  value: SchemaOrgRecipe['recipeInstructions']\n): InstructionItem[] {\n  if (!value) return [];\n  const normalized = Array.isArray(value) ? value : [value];\n  const result: InstructionItem[] = [];\n\n  for (const entry of normalized) {\n    if (!entry) continue;\n\n    if (typeof entry === 'string') {\n      const text = entry.trim();\n      if (text) {\n        result.push(text);\n      }\n      continue;\n    }\n\n    if (isHowToSection(entry)) {\n      const subsectionItems = extractSectionItems(entry.itemListElement);\n      if (subsectionItems.length) {\n        result.push({\n          subsection: entry.name?.trim() || 'Section',\n          items: subsectionItems\n        });\n      }\n      continue;\n    }\n\n    if (isHowToStep(entry)) {\n      const parsed = convertHowToStep(entry);\n      if (parsed) {\n        result.push(parsed);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction extractSectionItems(\n  items: Array<string | HowToStep | HowToSection> = []\n): Array<string | Instruction> {\n  const result: Array<string | Instruction> = [];\n\n  for (const item of items) {\n    if (!item) continue;\n\n    if (typeof item === 'string') {\n      const text = item.trim();\n      if (text) {\n        result.push(text);\n      }\n      continue;\n    }\n\n    if (isHowToStep(item)) {\n      const parsed = convertHowToStep(item);\n      if (parsed) {\n        result.push(parsed);\n      }\n      continue;\n    }\n\n    if (isHowToSection(item)) {\n      result.push(...extractSectionItems(item.itemListElement));\n    }\n  }\n\n  return result;\n}\n\nfunction extractInstructionText(value: HowToStep): string | undefined {\n  const text = typeof value.text === 'string' ? value.text : value.name;\n  return typeof text === 'string' ? text.trim() || undefined : undefined;\n}\n\nfunction convertHowToStep(step: HowToStep): string | Instruction | undefined {\n  const text = extractInstructionText(step);\n  if (!text) {\n    return undefined;\n  }\n\n  const normalizedImage = normalizeImage(step.image);\n  const image = Array.isArray(normalizedImage)\n    ? normalizedImage[0]\n    : normalizedImage;\n  const id = extractInstructionId(step);\n  const timing = extractInstructionTiming(step);\n\n  if (!image && !id && !timing) {\n    return text;\n  }\n\n  const instruction: Instruction = { text };\n  if (id) instruction.id = id;\n  if (image) instruction.image = image;\n  if (timing) instruction.timing = timing;\n\n  return instruction;\n}\n\nfunction extractInstructionTiming(step: HowToStep): StepTiming | undefined {\n  const duration =\n    step.totalTime || step.performTime || step.prepTime || (step as any).duration;\n\n  if (!duration || typeof duration !== 'string') {\n    return undefined;\n  }\n\n  const parsed = smartParseDuration(duration);\n  return { duration: parsed ?? duration, type: 'active' };\n}\n\nfunction extractInstructionId(step: HowToStep): string | undefined {\n  const raw = (step as any)['@id'] || (step as any).id || step.url;\n  if (typeof raw !== 'string') {\n    return undefined;\n  }\n  const trimmed = raw.trim();\n  return trimmed || undefined;\n}\n\nfunction isHowToStep(value: unknown): value is HowToStep {\n  return (\n    Boolean(value) &&\n    typeof value === 'object' &&\n    (value as HowToStep)['@type'] === 'HowToStep'\n  );\n}\n\nfunction isHowToSection(value: unknown): value is HowToSection {\n  return (\n    Boolean(value) &&\n    typeof value === 'object' &&\n    (value as HowToSection)['@type'] === 'HowToSection' &&\n    Array.isArray((value as HowToSection).itemListElement)\n  );\n}\n\nfunction convertTime(recipe: SchemaOrgRecipe): StructuredTime | undefined {\n  const prep = smartParseDuration(recipe.prepTime ?? '');\n  const cook = smartParseDuration(recipe.cookTime ?? '');\n  const total = smartParseDuration(recipe.totalTime ?? '');\n\n  const structured: StructuredTime = {};\n  if (prep !== null && prep !== undefined) structured.prep = prep;\n  if (cook !== null && cook !== undefined) structured.active = cook;\n  if (total !== null && total !== undefined) structured.total = total;\n\n  return Object.keys(structured).length ? structured : undefined;\n}\n\nfunction collectTags(cuisine: unknown, keywords: unknown): string[] {\n  const tags = new Set<string>();\n  flattenStrings(cuisine).forEach(tag => tags.add(tag));\n  if (typeof keywords === 'string') {\n    splitKeywords(keywords).forEach(tag => tags.add(tag));\n  } else {\n    flattenStrings(keywords).forEach(tag => tags.add(tag));\n  }\n  return Array.from(tags);\n}\n\nfunction splitKeywords(value: string): string[] {\n  return value\n    .split(/[,|]/)\n    .map(part => part.trim())\n    .filter(Boolean);\n}\n\nfunction flattenStrings(value: unknown): string[] {\n  if (!value) return [];\n  if (typeof value === 'string') return [value.trim()].filter(Boolean);\n  if (Array.isArray(value)) {\n    return value\n      .map(item => (typeof item === 'string' ? item.trim() : ''))\n      .filter(Boolean);\n  }\n  return [];\n}\n\nfunction extractFirst(value: unknown): string | undefined {\n  const arr = flattenStrings(value);\n  return arr.length ? arr[0] : undefined;\n}\n\nfunction convertSource(recipe: SchemaOrgRecipe): Source | undefined {\n  const author = extractEntityName(recipe.author);\n  const publisher = extractEntityName(recipe.publisher);\n  const url = (recipe.url || recipe.mainEntityOfPage)?.trim();\n\n  const source: Source = {};\n  if (author) source.author = author;\n  if (publisher) source.name = publisher;\n  if (url) source.url = url;\n\n  return Object.keys(source).length ? source : undefined;\n}\n\nfunction extractEntityName(\n  value:\n    | SchemaOrgPersonOrOrganization\n    | SchemaOrgPersonOrOrganization[]\n    | string\n    | string[]\n    | undefined\n): string | undefined {\n  if (!value) return undefined;\n\n  if (typeof value === 'string') {\n    const trimmed = value.trim();\n    return trimmed || undefined;\n  }\n\n  if (Array.isArray(value)) {\n    for (const entry of value) {\n      const name = extractEntityName(entry as any);\n      if (name) {\n        return name;\n      }\n    }\n    return undefined;\n  }\n\n  if (typeof value === 'object' && typeof value.name === 'string') {\n    const trimmed = value.name.trim();\n    return trimmed || undefined;\n  }\n\n  return undefined;\n}\n\nfunction convertAttribution(recipe: SchemaOrgRecipe): AttributionModule | undefined {\n  const attribution: AttributionModule = {};\n  const url = (recipe.url || recipe.mainEntityOfPage)?.trim();\n  const author = extractEntityName(recipe.author);\n  const datePublished = recipe.datePublished?.trim();\n\n  if (url) attribution.url = url;\n  if (author) attribution.author = author;\n  if (datePublished) attribution.datePublished = datePublished;\n\n  return Object.keys(attribution).length ? attribution : undefined;\n}\n\nfunction convertTaxonomy(\n  keywords: string[],\n  category?: string,\n  cuisine?: string\n): TaxonomyModule | undefined {\n  const taxonomy: TaxonomyModule = {};\n  if (keywords.length) taxonomy.keywords = keywords;\n  if (category) taxonomy.category = category;\n  if (cuisine) taxonomy.cuisine = cuisine;\n\n  return Object.keys(taxonomy).length ? taxonomy : undefined;\n}\n\nfunction normalizeMediaList(value: SchemaOrgImage | undefined): string[] {\n  if (!value) return [];\n  if (typeof value === 'string') return [value.trim()].filter(Boolean);\n  if (Array.isArray(value)) {\n    return value\n      .map(item => (typeof item === 'string' ? item.trim() : extractMediaUrl(item)))\n      .filter((entry): entry is string => Boolean(entry?.length));\n  }\n\n  const url = extractMediaUrl(value);\n  return url ? [url] : [];\n}\n\nfunction extractMediaUrl(value: unknown): string | undefined {\n  if (value && typeof value === 'object' && 'url' in value && typeof (value as any).url === 'string') {\n    const trimmed = (value as any).url.trim();\n    return trimmed || undefined;\n  }\n  return undefined;\n}\n\nfunction convertMedia(\n  image: SchemaOrgImage | undefined,\n  video: SchemaOrgImage | undefined\n): MediaModule | undefined {\n  const normalizedImage = normalizeImage(image);\n  const images = normalizedImage\n    ? Array.isArray(normalizedImage)\n      ? normalizedImage\n      : [normalizedImage]\n    : [];\n  const videos = normalizeMediaList(video);\n\n  const media: MediaModule = {};\n  if (images.length) media.images = images;\n  if (videos.length) media.videos = videos;\n\n  return Object.keys(media).length ? media : undefined;\n}\n\nfunction convertTimes(time?: StructuredTime): TimesModule | undefined {\n  if (!time) return undefined;\n  const times: TimesModule = {};\n\n  if (typeof time.prep === 'number') times.prepMinutes = time.prep;\n  if (typeof time.active === 'number') times.cookMinutes = time.active;\n  if (typeof time.total === 'number') times.totalMinutes = time.total;\n\n  return Object.keys(times).length ? times : undefined;\n}\n\nfunction convertNutrition(\n  nutrition: SchemaOrgRecipe['nutrition']\n): NutritionFacts | undefined {\n  if (!nutrition || typeof nutrition !== 'object') {\n    return undefined;\n  }\n\n  const result: NutritionFacts = {};\n  let hasData = false;\n\n  // Parse calories - can be string or number in Schema.org\n  if ('calories' in nutrition) {\n    const calories = nutrition.calories;\n    if (typeof calories === 'number') {\n      result.calories = calories;\n      hasData = true;\n    } else if (typeof calories === 'string') {\n      // Try to parse string like \"200 cal\" or \"200\"\n      const parsed = parseFloat(calories.replace(/[^\\d.-]/g, ''));\n      if (!isNaN(parsed)) {\n        result.calories = parsed;\n        hasData = true;\n      }\n    }\n  }\n\n  // Parse protein - Schema.org uses \"proteinContent\", we need \"protein_g\"\n  if ('proteinContent' in nutrition || 'protein_g' in nutrition) {\n    const protein = nutrition.proteinContent || nutrition.protein_g;\n    if (typeof protein === 'number') {\n      result.protein_g = protein;\n      hasData = true;\n    } else if (typeof protein === 'string') {\n      // Try to parse string like \"10 g\" or \"10\"\n      const parsed = parseFloat(protein.replace(/[^\\d.-]/g, ''));\n      if (!isNaN(parsed)) {\n        result.protein_g = parsed;\n        hasData = true;\n      }\n    }\n  }\n\n  return hasData ? result : undefined;\n}\n","import type { FetchImplementation, FetchOptions, FetchRequestInit } from './types';\n\nconst DEFAULT_USER_AGENTS = [\n  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n  'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0'\n];\n\nfunction chooseUserAgent(provided?: string): string {\n  if (provided) return provided;\n  const index = Math.floor(Math.random() * DEFAULT_USER_AGENTS.length);\n  return DEFAULT_USER_AGENTS[index];\n}\n\nfunction resolveFetch(fetchFn?: FetchImplementation): FetchImplementation {\n  if (fetchFn) {\n    return fetchFn;\n  }\n\n  const globalFetch = (globalThis as { fetch?: FetchImplementation }).fetch;\n  if (!globalFetch) {\n    throw new Error(\n      'A global fetch implementation is not available. Provide window.fetch in browsers or upgrade to Node 18+.'\n    );\n  }\n\n  return globalFetch;\n}\n\nfunction isBrowserEnvironment(): boolean {\n  return typeof (globalThis as { document?: unknown }).document !== 'undefined';\n}\n\nfunction isClientError(error: Error & { status?: number }): boolean {\n  if (typeof error.status === 'number') {\n    return error.status >= 400 && error.status < 500;\n  }\n  return error.message.includes('HTTP 4');\n}\n\nasync function wait(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport async function fetchPage(url: string, options: FetchOptions = {}): Promise<string> {\n  const {\n    timeout = 10_000,\n    userAgent,\n    maxRetries = 2,\n    fetchFn\n  } = options;\n\n  let lastError: Error | null = null;\n  const resolvedFetch = resolveFetch(fetchFn);\n  const isBrowser = isBrowserEnvironment();\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    try {\n      const headers: Record<string, string> = {\n        Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n        'Accept-Language': 'en-US,en;q=0.5'\n      };\n\n      if (!isBrowser) {\n        headers['User-Agent'] = chooseUserAgent(userAgent);\n      }\n\n      const requestInit: FetchRequestInit = {\n        headers,\n        signal: controller.signal,\n        redirect: 'follow'\n      };\n\n      const response = await resolvedFetch(url, requestInit);\n\n      clearTimeout(timeoutId);\n      if (response && typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n        const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;\n        if (ingestUrl) {\n          try {\n            const globalFetch = typeof globalThis !== 'undefined' && typeof globalThis.fetch !== 'undefined' ? globalThis.fetch : null;\n            if (globalFetch) {\n              globalFetch(ingestUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'scraper/fetch.ts:63',message:'fetch response',data:{url,status:response.status,statusText:response.statusText,ok:response.ok,isNYTimes:url.includes('nytimes.com')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});\n            }\n          } catch {}\n        }\n      }\n\n      if (!response.ok) {\n        const error: Error & { status?: number } = new Error(\n          `HTTP ${response.status}: ${response.statusText}`\n        );\n        error.status = response.status;\n        throw error;\n      }\n\n      const html = await response.text();\n      if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n        const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;\n        if (ingestUrl) {\n          try {\n            const globalFetch = typeof globalThis !== 'undefined' && typeof globalThis.fetch !== 'undefined' ? globalThis.fetch : null;\n            if (globalFetch) {\n              globalFetch(ingestUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'scraper/fetch.ts:75',message:'HTML received',data:{htmlLength:html.length,hasLoginPage:html.toLowerCase().includes('login')||html.toLowerCase().includes('sign in'),hasRecipeData:html.includes('application/ld+json')||html.includes('schema.org/Recipe')},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B,D'})}).catch(()=>{});\n            }\n          } catch {}\n        }\n      }\n      return html;\n    } catch (err) {\n      clearTimeout(timeoutId);\n\n      lastError = err instanceof Error ? err : new Error(String(err));\n\n      if (isClientError(lastError)) {\n        throw lastError;\n      }\n\n      if (attempt < maxRetries) {\n        await wait(1000 * (attempt + 1));\n        continue;\n      }\n    }\n  }\n\n  throw lastError ?? new Error('Failed to fetch page');\n}\n\nexport { FetchOptions };\n","import type { SchemaOrgRecipe } from '../types';\n\nconst RECIPE_TYPES = new Set([\n  'recipe',\n  'https://schema.org/recipe',\n  'http://schema.org/recipe'\n]);\n\nexport function isRecipeNode(value: unknown): value is SchemaOrgRecipe {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n\n  const type = (value as Record<string, unknown>)['@type'];\n\n  if (typeof type === 'string') {\n    return RECIPE_TYPES.has(type.toLowerCase());\n  }\n\n  if (Array.isArray(type)) {\n    return type.some(\n      entry => typeof entry === 'string' && RECIPE_TYPES.has(entry.toLowerCase())\n    );\n  }\n\n  return false;\n}\n\nexport function safeJsonParse<T = unknown>(content: string): T | null {\n  try {\n    return JSON.parse(content) as T;\n  } catch {\n    return null;\n  }\n}\n\nexport function normalizeText(value: string | undefined | null): string | undefined {\n  if (!value) return undefined;\n  const trimmed = value.replace(/\\s+/g, ' ').trim();\n  return trimmed || undefined;\n}\n","import { load } from 'cheerio';\nimport type { SchemaOrgRecipe } from '../types';\nimport { isRecipeNode, safeJsonParse } from './utils';\n\ntype JsonLdPayload = Record<string, unknown> | Array<Record<string, unknown>>;\n\nexport function extractJsonLd(html: string): SchemaOrgRecipe | null {\n  const $ = load(html);\n  const scripts = $('script[type=\"application/ld+json\"]');\n  const candidates: SchemaOrgRecipe[] = [];\n\n  scripts.each((_, element) => {\n    const content = $(element).html();\n    if (!content) return;\n\n    const parsed = safeJsonParse<JsonLdPayload>(content);\n    if (!parsed) return;\n\n    collectCandidates(parsed, candidates);\n  });\n\n  return candidates[0] ?? null;\n}\n\nfunction collectCandidates(payload: unknown, bucket: SchemaOrgRecipe[]) {\n  if (!payload) return;\n\n  if (Array.isArray(payload)) {\n    payload.forEach(entry => collectCandidates(entry, bucket));\n    return;\n  }\n\n  if (typeof payload !== 'object') {\n    return;\n  }\n\n  if (isRecipeNode(payload)) {\n    bucket.push(payload);\n    return;\n  }\n\n  const graph = (payload as Record<string, unknown>)['@graph'];\n  if (Array.isArray(graph)) {\n    graph.forEach(entry => collectCandidates(entry, bucket));\n  }\n}\n","import { load, type CheerioAPI, type Cheerio } from 'cheerio';\nimport type { SchemaOrgRecipe } from '../types';\nimport { normalizeText } from './utils';\n\nconst SIMPLE_PROPS = [\n  'name',\n  'description',\n  'image',\n  'recipeYield',\n  'prepTime',\n  'cookTime',\n  'totalTime'\n] as const;\n\nexport function extractMicrodata(html: string): SchemaOrgRecipe | null {\n  const $ = load(html);\n  const recipeEl = $('[itemscope][itemtype*=\"schema.org/Recipe\"]').first();\n\n  if (!recipeEl.length) {\n    return null;\n  }\n\n  const recipe: SchemaOrgRecipe = {\n    '@type': 'Recipe'\n  };\n\n  SIMPLE_PROPS.forEach(prop => {\n    const value = findPropertyValue($, recipeEl, prop);\n    if (value) {\n      recipe[prop] = value;\n    }\n  });\n\n  const ingredients: string[] = [];\n  recipeEl.find('[itemprop=\"recipeIngredient\"]').each((_, el) => {\n    const text = normalizeText($(el).attr('content') || $(el).text());\n    if (text) ingredients.push(text);\n  });\n\n  if (ingredients.length) {\n    recipe.recipeIngredient = ingredients;\n  }\n\n  const instructions: string[] = [];\n  recipeEl.find('[itemprop=\"recipeInstructions\"]').each((_, el) => {\n    const text =\n      normalizeText($(el).attr('content')) ||\n      normalizeText($(el).find('[itemprop=\"text\"]').first().text()) ||\n      normalizeText($(el).text());\n    if (text) instructions.push(text);\n  });\n\n  if (instructions.length) {\n    recipe.recipeInstructions = instructions;\n  }\n\n  if (recipe.name || ingredients.length) {\n    return recipe;\n  }\n\n  return null;\n}\n\nfunction findPropertyValue($: CheerioAPI, context: Cheerio<any>, prop: string): string | undefined {\n  const node = context.find(`[itemprop=\"${prop}\"]`).first();\n  if (!node.length) return undefined;\n\n  return (\n    normalizeText(node.attr('content')) ||\n    normalizeText(node.attr('href')) ||\n    normalizeText(node.attr('src')) ||\n    normalizeText(node.text())\n  );\n}\n","import type { ExtractionResult, SchemaOrgRecipe } from '../types';\nimport { isRecipeNode, safeJsonParse, normalizeText } from './utils';\n\ntype JsonLdPayload = Record<string, unknown> | Array<Record<string, unknown>>;\n\nconst SIMPLE_PROPS = ['name', 'description', 'image', 'recipeYield', 'prepTime', 'cookTime', 'totalTime'] as const;\n\nexport function extractRecipeBrowser(html: string): ExtractionResult {\n  // Extract JSON-LD\n  const jsonLdRecipe = extractJsonLdBrowser(html);\n  if (jsonLdRecipe) {\n    return { recipe: jsonLdRecipe, source: 'jsonld' };\n  }\n\n  // Extract Microdata\n  const microdataRecipe = extractMicrodataBrowser(html);\n  if (microdataRecipe) {\n    return { recipe: microdataRecipe, source: 'microdata' };\n  }\n\n  return { recipe: null, source: null };\n}\n\nfunction extractJsonLdBrowser(html: string): SchemaOrgRecipe | null {\n  if (typeof (globalThis as any).DOMParser === 'undefined') {\n    return null;\n  }\n\n  const parser = new (globalThis as any).DOMParser();\n  const doc = parser.parseFromString(html, 'text/html');\n  const scripts = doc.querySelectorAll('script[type=\"application/ld+json\"]');\n  const candidates: SchemaOrgRecipe[] = [];\n\n  scripts.forEach((script: Element) => {\n    const content = script.textContent;\n    if (!content) return;\n\n    const parsed = safeJsonParse<JsonLdPayload>(content);\n    if (!parsed) return;\n\n    collectCandidates(parsed, candidates);\n  });\n\n  return candidates[0] ?? null;\n}\n\nfunction extractMicrodataBrowser(html: string): SchemaOrgRecipe | null {\n  if (typeof (globalThis as any).DOMParser === 'undefined') {\n    return null;\n  }\n\n  const parser = new (globalThis as any).DOMParser();\n  const doc = parser.parseFromString(html, 'text/html');\n  const recipeEl = doc.querySelector('[itemscope][itemtype*=\"schema.org/Recipe\"]');\n\n  if (!recipeEl) {\n    return null;\n  }\n\n  const recipe: SchemaOrgRecipe = {\n    '@type': 'Recipe'\n  };\n\n  SIMPLE_PROPS.forEach(prop => {\n    const value = findPropertyValue(recipeEl, prop);\n    if (value) {\n      recipe[prop] = value;\n    }\n  });\n\n  const ingredients: string[] = [];\n  recipeEl.querySelectorAll('[itemprop=\"recipeIngredient\"]').forEach((el: Element) => {\n    const text = normalizeText(\n      (el as any).getAttribute('content') || el.textContent || undefined\n    );\n    if (text) ingredients.push(text);\n  });\n\n  if (ingredients.length) {\n    recipe.recipeIngredient = ingredients;\n  }\n\n  const instructions: string[] = [];\n  recipeEl.querySelectorAll('[itemprop=\"recipeInstructions\"]').forEach((el: Element) => {\n    const text =\n      normalizeText((el as any).getAttribute('content')) ||\n      normalizeText(el.querySelector('[itemprop=\"text\"]')?.textContent || undefined) ||\n      normalizeText(el.textContent || undefined);\n    if (text) instructions.push(text);\n  });\n\n  if (instructions.length) {\n    recipe.recipeInstructions = instructions;\n  }\n\n  if (recipe.name || ingredients.length) {\n    return recipe;\n  }\n\n  return null;\n}\n\nfunction findPropertyValue(context: Element, prop: string): string | undefined {\n  const node = context.querySelector(`[itemprop=\"${prop}\"]`);\n  if (!node) return undefined;\n\n  return (\n    normalizeText((node as any).getAttribute('content')) ||\n    normalizeText((node as any).getAttribute('href')) ||\n    normalizeText((node as any).getAttribute('src')) ||\n    normalizeText(node.textContent || undefined)\n  );\n}\n\nfunction collectCandidates(payload: unknown, bucket: SchemaOrgRecipe[]) {\n  if (!payload) return;\n\n  if (Array.isArray(payload)) {\n    payload.forEach(entry => collectCandidates(entry, bucket));\n    return;\n  }\n\n  if (typeof payload !== 'object') {\n    return;\n  }\n\n  if (isRecipeNode(payload)) {\n    bucket.push(payload);\n    return;\n  }\n\n  const graph = (payload as Record<string, unknown>)['@graph'];\n  if (Array.isArray(graph)) {\n    graph.forEach(entry => collectCandidates(entry, bucket));\n  }\n}\n\n","import type { ExtractionResult } from '../types';\nimport { extractJsonLd } from './jsonld';\nimport { extractMicrodata } from './microdata';\nimport { extractRecipeBrowser } from './browser';\n\nfunction isBrowser(): boolean {\n  try {\n    // Check if we're in a browser environment with DOMParser\n    return typeof (globalThis as any).DOMParser !== 'undefined';\n  } catch {\n    return false;\n  }\n}\n\nexport function extractRecipe(html: string): ExtractionResult {\n  // Use browser-compatible extraction if DOMParser is available\n  if (isBrowser()) {\n    return extractRecipeBrowser(html);\n  }\n  \n  // Fallback to cheerio-based extraction for Node.js\n  const jsonLdRecipe = extractJsonLd(html);\n  if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;\n    if (ingestUrl) {\n      try {\n        const globalFetch = typeof globalThis !== 'undefined' && typeof globalThis.fetch !== 'undefined' ? globalThis.fetch : null;\n        if (globalFetch) {\n          globalFetch(ingestUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'scraper/extractors/index.ts:6',message:'JSON-LD extraction result',data:{hasJsonLd:!!jsonLdRecipe},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C,D'})}).catch(()=>{});\n        }\n      } catch {}\n    }\n  }\n  if (jsonLdRecipe) {\n    return { recipe: jsonLdRecipe, source: 'jsonld' };\n  }\n\n  const microdataRecipe = extractMicrodata(html);\n  if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;\n    if (ingestUrl) {\n      try {\n        const globalFetch = typeof globalThis !== 'undefined' && typeof globalThis.fetch !== 'undefined' ? globalThis.fetch : null;\n        if (globalFetch) {\n          globalFetch(ingestUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'scraper/extractors/index.ts:12',message:'Microdata extraction result',data:{hasMicrodata:!!microdataRecipe},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});\n        }\n      } catch {}\n    }\n  }\n  if (microdataRecipe) {\n    return { recipe: microdataRecipe, source: 'microdata' };\n  }\n\n  return { recipe: null, source: null };\n}\n","import { fromSchemaOrg } from '../fromSchemaOrg';\nimport type { Recipe } from '../types';\nimport { fetchPage } from './fetch';\nimport { extractRecipe } from './extractors';\nimport type { ScrapeRecipeOptions, SchemaOrgRecipe } from './types';\n\n/**\n * Scrapes a recipe from a URL (Node.js only).\n * \n *  Not available in browser environments due to CORS restrictions.\n * For browser usage, fetch the HTML yourself and use extractRecipeFromHTML().\n * \n * @param url - The URL of the recipe page to scrape\n * @param options - Fetch options (timeout, userAgent, maxRetries)\n * @returns A Soustack recipe object\n * @throws Error if no recipe is found\n */\nexport async function scrapeRecipe(url: string, options: ScrapeRecipeOptions = {}): Promise<Recipe> {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;\n    if (ingestUrl) {\n      try {\n        const globalFetch = typeof globalThis !== 'undefined' && typeof globalThis.fetch !== 'undefined' ? globalThis.fetch : null;\n        if (globalFetch) {\n          globalFetch(ingestUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'scraper/index.ts:7',message:'scrapeRecipe entry',data:{url,hasOptions:!!options},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C,D,E'})}).catch(()=>{});\n        }\n      } catch {}\n    }\n  }\n  const html = await fetchPage(url, options);\n  if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;\n    if (ingestUrl) {\n      try {\n        const globalFetch = typeof globalThis !== 'undefined' && typeof globalThis.fetch !== 'undefined' ? globalThis.fetch : null;\n        if (globalFetch) {\n          globalFetch(ingestUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'scraper/index.ts:9',message:'HTML fetched',data:{htmlLength:html?.length,htmlPreview:html?.substring(0,200)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});\n        }\n      } catch {}\n    }\n  }\n  const { recipe } = extractRecipe(html);\n  if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;\n    if (ingestUrl) {\n      try {\n        const globalFetch = typeof globalThis !== 'undefined' && typeof globalThis.fetch !== 'undefined' ? globalThis.fetch : null;\n        if (globalFetch) {\n          globalFetch(ingestUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'scraper/index.ts:11',message:'extractRecipe result',data:{hasRecipe:!!recipe,recipeType:recipe?.['@type'],recipeName:recipe?.name},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,C,D'})}).catch(()=>{});\n        }\n      } catch {}\n    }\n  }\n\n  if (!recipe) {\n    throw new Error('No Schema.org recipe data found in page');\n  }\n\n  const soustackRecipe = fromSchemaOrg(recipe);\n  if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'test') {\n    const ingestUrl = process.env.SOUSTACK_DEBUG_INGEST_URL;\n    if (ingestUrl) {\n      try {\n        const globalFetch = typeof globalThis !== 'undefined' && typeof globalThis.fetch !== 'undefined' ? globalThis.fetch : null;\n        if (globalFetch) {\n          globalFetch(ingestUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'scraper/index.ts:17',message:'fromSchemaOrg result',data:{hasSoustackRecipe:!!soustackRecipe,soustackRecipeName:soustackRecipe?.name},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});\n        }\n      } catch {}\n    }\n  }\n  if (!soustackRecipe) {\n    throw new Error('Schema.org data did not include a valid recipe');\n  }\n\n  return soustackRecipe;\n}\n\n/**\n * Extracts a recipe from HTML string (browser and Node.js compatible).\n * \n * This function works in both environments and doesn't require network access.\n * Perfect for browser usage where you fetch HTML yourself (with cookies/session).\n * \n * @example\n * ```ts\n * // In browser:\n * const response = await fetch('https://example.com/recipe');\n * const html = await response.text();\n * const recipe = extractRecipeFromHTML(html);\n * ```\n * \n * @param html - The HTML string containing Schema.org recipe data\n * @returns A Soustack recipe object\n * @throws Error if no recipe is found\n */\nexport function extractRecipeFromHTML(html: string): Recipe {\n  const { recipe } = extractRecipe(html);\n\n  if (!recipe) {\n    throw new Error('No Schema.org recipe data found in HTML');\n  }\n\n  const soustackRecipe = fromSchemaOrg(recipe);\n  if (!soustackRecipe) {\n    throw new Error('Schema.org data did not include a valid recipe');\n  }\n\n  return soustackRecipe;\n}\n\n/**\n * Extract Schema.org recipe data from HTML string (browser-compatible).\n * \n * Returns the raw Schema.org recipe object, which can then be converted\n * to Soustack format using fromSchemaOrg(). This gives you access to the\n * original Schema.org data for inspection, debugging, or custom transformations.\n * \n * @param html - HTML string containing Schema.org recipe data\n * @returns Schema.org recipe object, or null if not found\n * \n * @example\n * ```ts\n * // In browser:\n * const response = await fetch('https://example.com/recipe');\n * const html = await response.text();\n * const schemaOrgRecipe = extractSchemaOrgRecipeFromHTML(html);\n * \n * if (schemaOrgRecipe) {\n *   // Inspect or modify Schema.org data before converting\n *   console.log('Found recipe:', schemaOrgRecipe.name);\n *   \n *   // Convert to Soustack format\n *   const soustackRecipe = fromSchemaOrg(schemaOrgRecipe);\n * }\n * ```\n */\nexport function extractSchemaOrgRecipeFromHTML(html: string): SchemaOrgRecipe | null {\n  const { recipe } = extractRecipe(html);\n  return recipe;\n}\n"]}