/**
 * Soustack Recipe Schema v0.3.0
 * A portable, scalable, interoperable recipe format.
 */
interface SoustackRecipe {
    /** Document marker for Soustack recipes */
    '@type'?: 'Recipe';
    /** Optional $schema pointer for profile-aware validation */
    $schema?: string;
    /** Optional declared validation profile */
    profile?: string;
    /** Recipe level: "lite" or "base" */
    level?: "lite" | "base";
    /** Stack declarations as a map: Record<stackName, versionNumber> */
    stacks?: Record<string, number>;
    /** Attribution stack payload */
    attribution?: AttributionModule;
    /** Taxonomy stack payload */
    taxonomy?: TaxonomyModule;
    /** Media stack payload */
    media?: MediaModule;
    /** Times stack payload */
    times?: TimesModule;
    /** Unique identifier (slug or UUID) */
    id?: string;
    /** Optional display title */
    title?: string;
    /** The title of the recipe */
    name: string;
    /** Semantic versioning (e.g., 1.0.0) */
    recipeVersion?: string;
    /** Deprecated alias for recipeVersion */
    version?: string;
    description?: string;
    /** Primary category (e.g., "Main Course") */
    category?: string;
    /** Additional tags for filtering */
    tags?: string[];
    /** URL(s) to recipe image(s) */
    image?: string | string[];
    /** ISO 8601 date string */
    dateAdded?: string;
    /** Last updated timestamp */
    dateModified?: string;
    source?: Source;
    yield?: Yield;
    time?: Time;
    equipment?: Equipment[];
    ingredients: IngredientItem[];
    instructions: InstructionItem[];
    storage?: Storage;
    substitutions?: Substitution[];
    nutrition?: NutritionFacts;
    metadata?: Record<string, unknown>;
    [k: `x-${string}`]: unknown;
}
type Recipe = SoustackRecipe;
interface Source {
    author?: string;
    url?: string;
    name?: string;
    adapted?: boolean;
}
interface Yield {
    amount: number;
    unit: string;
    servings?: number;
    description?: string;
}
interface ParsedYield {
    amount: number;
    unit: string;
    servings?: number;
    description?: string;
}
/**
 * Time can be structured (machine-readable) or simple (strings).
 * Structured time takes precedence if both exist.
 */
type Time = StructuredTime | SimpleTime;
interface StructuredTime {
    prep?: number;
    active?: number;
    passive?: number;
    total?: number;
}
interface SimpleTime {
    prepTime?: string;
    cookTime?: string;
}
interface Equipment {
    id?: string;
    name: string;
    required?: boolean;
    label?: string;
    capacity?: Quantity$1;
    scalingLimit?: number;
    alternatives?: string[];
}
interface Quantity$1 {
    amount: number;
    /** Unit string (e.g. "g", "cup") or null for count-based items (e.g. "2 eggs") */
    unit: string | null;
}
type IngredientItem = string | Ingredient$1 | IngredientSubsection;
interface IngredientSubsection {
    subsection: string;
    items: (string | Ingredient$1)[];
}
interface Ingredient$1 {
    id?: string;
    /** Full human-readable text (e.g. "2 cups flour") */
    item: string;
    quantity?: Quantity$1;
    name?: string;
    aisle?: string;
    /** Required prep state (e.g. "diced") */
    prep?: string;
    prepAction?: string;
    prepTime?: number;
    /** ID of equipment where this ingredient goes */
    destination?: string;
    scaling?: Scaling;
    critical?: boolean;
    optional?: boolean;
    notes?: string;
}
interface ParsedIngredient {
    item: string;
    quantity?: {
        amount: number | null;
        unit: string | null;
    };
    name?: string;
    prep?: string;
    optional?: boolean;
    notes?: string;
    scaling?: Scaling;
}
/**
 * Intelligent Scaling Logic
 * Defines how an ingredient behaves when the recipe yield changes.
 */
type Scaling = ScalingLinear | ScalingDiscrete | ScalingProportional | ScalingFixed | ScalingBakersPercentage;
interface ScalingBase {
    min?: number;
    max?: number;
}
interface ScalingLinear extends ScalingBase {
    type: "linear";
}
interface ScalingDiscrete extends ScalingBase {
    type: "discrete";
    roundTo?: number;
}
interface ScalingProportional extends ScalingBase {
    type: "proportional";
    factor?: number;
}
interface ScalingFixed extends ScalingBase {
    type: "fixed";
}
interface ScalingBakersPercentage extends ScalingBase {
    type: 'bakers_percentage';
    /** The ID of the flour/base ingredient this is relative to */
    referenceId: string;
    /** The percentage relative to the reference (e.g. 0.02 for 2%) */
    factor?: number;
}
type InstructionItem = string | Instruction | InstructionSubsection;
interface InstructionSubsection {
    subsection: string;
    items: (string | Instruction)[];
}
interface SoustackInstruction {
    id?: string;
    text: string;
    destination?: string;
    /** IDs of steps that must complete before this one starts */
    dependsOn?: string[];
    /** IDs of ingredients used in this step */
    inputs?: string[];
    timing?: StepTiming;
    /** Optional image URL for this instruction */
    image?: string;
}
type Instruction = SoustackInstruction;
interface StepTiming {
    duration: number | string;
    type: "active" | "passive";
    scaling?: "linear" | "fixed" | "sqrt";
}
interface Storage {
    roomTemp?: StorageMethod;
    refrigerated?: StorageMethod;
    frozen?: FrozenStorageMethod;
    reheating?: string;
    makeAhead?: MakeAheadComponent[];
}
interface StorageMethod {
    /** ISO 8601 duration (e.g. P3D) */
    duration: string;
    method?: string;
    notes?: string;
}
interface FrozenStorageMethod extends StorageMethod {
    thawing?: string;
}
interface MakeAheadComponent extends StorageMethod {
    component: string;
    storage: "roomTemp" | "refrigerated" | "frozen";
}
interface Substitution {
    ingredient: string;
    critical?: boolean;
    notes?: string;
    alternatives?: Alternative[];
}
interface Alternative {
    name: string;
    ratio: string;
    notes?: string;
    impact?: string;
    dietary?: string[];
}
interface NutritionFacts {
    calories?: number;
    protein_g?: number;
}
interface AttributionModule {
    url?: string;
    author?: string;
    datePublished?: string;
}
interface TaxonomyModule {
    keywords?: string[];
    category?: string;
    cuisine?: string;
}
interface MediaModule {
    images?: string[];
    videos?: string[];
}
interface TimesModule {
    prepMinutes?: number;
    cookMinutes?: number;
    totalMinutes?: number;
}

interface ScaleRecipeOptions {
    multiplier?: number;
    targetYield?: {
        amount: number;
        unit?: string;
    };
}
declare function scaleRecipe(recipe: Recipe, options?: ScaleRecipeOptions): Recipe;

type ConformanceSeverity = "error" | "warning";
interface ConformanceIssue {
    code: string;
    path: string;
    message: string;
    severity: ConformanceSeverity;
}

type ProfileName = "base" | "equipped" | "illustrated" | "lite" | "prepped" | "scalable" | "timed" | "minimal" | "core";
interface NormalizedError {
    path: string;
    message: string;
    keyword?: string;
}
/**
 * Validation modes for recipe validation.
 * - "schema": JSON Schema only
 * - "full": JSON Schema + semantic conformance checks
 */
type ValidateMode = "schema" | "full";
interface ValidateOptions {
    profile?: ProfileName;
    schema?: string;
    collectAllErrors?: boolean;
    mode?: ValidateMode;
    includeNormalized?: boolean;
}
/**
 * Result payload for recipe validation. Schema validation always runs first;
 * conformance issues are only included when running in full mode.
 */
interface ValidateResult {
    ok: boolean;
    schemaErrors: NormalizedError[];
    conformanceIssues: ConformanceIssue[];
    warnings: string[];
    normalizedRecipe?: Recipe;
}
/**
 * Legacy validateRecipe function - now uses the new validateRecipeSchema internally
 * but maintains backward compatibility with profile/stack-based validation
 * Also includes semantic conformance validation.
 */
/**
 * Validates a recipe with explicit validation modes.
 * - mode="schema": JSON Schema only
 * - mode="full": schema + semantic conformance (only if schema passes)
 */
declare function validateRecipe(input: any, options?: ValidateOptions): ValidateResult;
declare function detectProfiles(recipe: any): ProfileName[];

declare function fromSchemaOrg(input: unknown): Recipe | null;

interface NormalizationResult {
    recipe: Recipe;
    warnings: string[];
}
/**
 * Normalizes a recipe input to the current spec format:
 * - Rejects inputs with legacy field (unsupported)
 * - Converts legacy `stacks` array format to map format
 * - Ensures `stacks` exists even if empty
 * - Preserves existing `stacks` map format
 *
 * @param input - Raw recipe input (may have legacy formats)
 * @returns Normalized recipe with warnings for any issues encountered
 * @throws Error if input contains legacy field
 */
declare function normalizeRecipe(input: unknown): NormalizationResult;

interface SchemaOrgRecipe$1 {
    '@context'?: string | Array<string | Record<string, unknown>> | Record<string, unknown>;
    '@type'?: string | string[];
    name: string;
    description?: string;
    image?: SchemaOrgImage;
    recipeIngredient?: SchemaOrgIngredientList;
    recipeInstructions?: SchemaOrgInstructionList;
    recipeYield?: string | number | SchemaOrgYield | Array<string | number | SchemaOrgYield>;
    prepTime?: string;
    cookTime?: string;
    totalTime?: string;
    recipeCategory?: string | string[];
    recipeCuisine?: string | string[];
    keywords?: string;
    author?: SchemaOrgPersonOrOrganization | SchemaOrgPersonOrOrganization[] | string | string[];
    publisher?: SchemaOrgPersonOrOrganization | SchemaOrgPersonOrOrganization[] | string | string[];
    url?: string;
    mainEntityOfPage?: string;
    datePublished?: string;
    dateModified?: string;
    nutrition?: NutritionInformation;
    video?: SchemaOrgImage;
    '@graph'?: unknown;
}
type SchemaOrgIngredientList = string | string[];
type SchemaOrgInstructionList = string | HowToStep$1 | HowToSection | Array<string | HowToStep$1 | HowToSection>;
interface SchemaOrgImageObject {
    '@type'?: string;
    url?: string;
    contentUrl?: string;
    width?: number;
    height?: number;
    [key: string]: unknown;
}
type SchemaOrgImage = string | SchemaOrgImageObject | Array<string | SchemaOrgImageObject>;
interface SchemaOrgYield {
    amount?: number;
    unit?: string;
    description?: string;
}
interface HowToStep$1 {
    '@type': 'HowToStep';
    text?: string;
    name?: string;
    url?: string;
    image?: SchemaOrgImage;
    '@id'?: string;
    id?: string;
    totalTime?: string;
    performTime?: string;
    prepTime?: string;
    duration?: string;
}
interface HowToSection {
    '@type': 'HowToSection';
    name: string;
    itemListElement: Array<string | HowToStep$1 | HowToSection>;
}
interface SchemaOrgPersonOrOrganization {
    '@type'?: 'Person' | 'Organization';
    name?: string;
    url?: string;
}
interface NutritionInformation {
    [key: string]: string | number | null | undefined;
}

/**
 * Convert a Soustack recipe to Schema.org JSON-LD format.
 *
 * BREAKING CHANGE in v0.3.0: This function now targets the "minimal" profile
 * and only includes stacks that are schemaOrgMappable (as defined in the
 * stacks registry). Non-mappable stacks (e.g., nutrition@1, schedule@1)
 * are excluded from the conversion.
 */
declare function toSchemaOrg(recipe: Recipe): SchemaOrgRecipe$1;

interface HowToStep {
    '@type'?: 'HowToStep' | 'HowToSection' | string;
    name?: string;
    text?: string;
    itemListElement?: Array<string | HowToStep>;
}
interface SchemaOrgRecipe {
    '@type': string | string[];
    name?: string;
    description?: string;
    image?: string | string[];
    recipeIngredient?: string[];
    recipeInstructions?: Array<string | HowToStep>;
    recipeYield?: string | number;
    prepTime?: string;
    cookTime?: string;
    totalTime?: string;
    author?: unknown;
    datePublished?: string;
    aggregateRating?: unknown;
    [key: string]: unknown;
}

declare function extractSchemaOrgRecipeFromHTML(html: string): SchemaOrgRecipe | null;

declare const SOUSTACK_SPEC_VERSION = "0.3.0";

type ConvertTarget = 'metric';
type ConvertMode = 'volume' | 'mass';
type RoundMode = 'none' | 'sane';
interface LineItem {
    ingredient: string;
    quantity: number;
    unit: string | null;
}
interface ConvertedLineItem extends LineItem {
    notes?: string;
}
declare class UnknownUnitError extends Error {
    readonly unit: string;
    constructor(unit: string);
}
declare class UnsupportedConversionError extends Error {
    readonly unit: string;
    readonly mode: ConvertMode;
    constructor(unit: string, mode: ConvertMode);
}
declare class MissingEquivalencyError extends Error {
    readonly ingredient: string;
    readonly unit: string;
    constructor(ingredient: string, unit: string);
}
declare function convertLineItemToMetric(item: LineItem, mode: ConvertMode, opts?: {
    round?: RoundMode;
}): ConvertedLineItem;

interface Quantity {
    amount: number;
    unit?: string | null;
}
interface Ingredient {
    id?: string;
    item: string;
    quantity?: Quantity;
    name?: string;
    prep?: string;
    prepAction?: string;
    prepActions?: string[];
    form?: string;
    prepTime?: number;
    optional?: boolean;
    notes?: string;
}
interface MiseEnPlaceTask {
    category: 'prep' | 'state' | 'measure' | 'other';
    action?: string;
    form?: string;
    items: Array<{
        ingredient: string;
        quantity?: Quantity;
        optional?: boolean;
        notes?: string;
    }>;
}
interface MiseEnPlacePlan {
    tasks: MiseEnPlaceTask[];
    ungrouped: Ingredient[];
}
declare function miseEnPlace(ingredients: Ingredient[]): MiseEnPlacePlan;

export { type Alternative, type AttributionModule, type ConvertMode, type ConvertTarget, type ConvertedLineItem, type Equipment, type FrozenStorageMethod, type Ingredient$1 as Ingredient, type IngredientItem, type IngredientSubsection, type Instruction, type InstructionItem, type InstructionSubsection, type LineItem, type MakeAheadComponent, type MediaModule, type Ingredient as MiseEnPlaceIngredient, type MiseEnPlacePlan, type Quantity as MiseEnPlaceQuantity, type MiseEnPlaceTask, MissingEquivalencyError, type NormalizationResult, type NutritionFacts, type ParsedIngredient, type ParsedYield, type Quantity$1 as Quantity, type Recipe, type RoundMode, SOUSTACK_SPEC_VERSION, type Scaling, type ScalingBakersPercentage, type ScalingBase, type ScalingDiscrete, type ScalingFixed, type ScalingLinear, type ScalingProportional, type SimpleTime, type Source, type SoustackInstruction, type SoustackRecipe, type StepTiming, type Storage, type StorageMethod, type StructuredTime, type Substitution, type TaxonomyModule, type Time, type TimesModule, UnknownUnitError, UnsupportedConversionError, type ValidateMode, type ValidateResult, type Yield, convertLineItemToMetric, detectProfiles, extractSchemaOrgRecipeFromHTML, fromSchemaOrg, miseEnPlace, normalizeRecipe, scaleRecipe, toSchemaOrg, validateRecipe };
